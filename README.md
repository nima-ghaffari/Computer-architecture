# راهنمای جامع مدارهای Logisim-evolution (بر اساس فایل پروژه)

ما در این سند به تشریح کامل مدارهای طراحی شده در نرم‌افزار Logisim-evolution، که از فایل پروژه استخراج شده‌اند، می‌پردازیم. این مدارها هسته‌ی یک مسیر داده (Datapath) پردازنده را تشکیل می‌دهند و به منظور شبیه‌سازی عملکرد بخش‌های مختلف یک CPU طراحی شده‌اند. [cite_start]پروژه ما توسط Logisim-evolution نسخه‌ی 3.9.0 توسعه یافته است، که نسخه‌ی پیشرفته‌تر و متن‌باز Logisim اصلی است و قابلیت‌های بیشتری برای طراحی و تحلیل مدارهای منطقی دیجیتال ارائه می‌دهد[cite: 1, 2].

---

## ۱. ساختار فایل پروژه و کتابخانه‌ها

[cite_start]فایل پروژه Logisim-evolution علاوه بر تعاریف مدارها، شامل تنظیمات کلی محیط شبیه‌سازی و کتابخانه‌های مورد استفاده نیز می‌باشد[cite: 1, 2].

### ۱.۱. کتابخانه‌های مورد استفاده
[cite_start]در این پروژه، ما از کتابخانه‌های استاندارد Logisim-evolution استفاده کرده‌ایم که هر کدام مجموعه‌ای از اجزای پرکاربرد برای ساخت مدارهای دیجیتال را در خود جای داده‌اند[cite: 1, 2]:
* [cite_start]**#Wiring (سیم‌کشی)**: شامل ابزارهای اساسی برای اتصال و مسیریابی سیگنال‌ها مانند `Splitter` (جداکننده بیت‌ها از یک باس یا ترکیب آن‌ها)، `Pin` (پین‌های ورودی و خروجی مدار) و `Tunnel` (برای نامگذاری و اتصال سیگنال‌ها در فواصل دور برای افزایش خوانایی)[cite: 2].
* [cite_start]**#Gates (گیت‌ها)**: حاوی گیت‌های منطقی پایه مانند `AND`, `OR`, `NOT`, `XOR`, `NAND`, `NOR`[cite: 2].
* [cite_start]**#Plexers (مالتی‌پلکسرها)**: شامل `Multiplexer` (انتخاب یکی از چند ورودی) و `Demultiplexer` (هدایت یک ورودی به یکی از چند خروجی)[cite: 2].
* [cite_start]**#Arithmetic (محاسبات)**: اجزای مربوط به عملیات محاسباتی و منطقی نظیر `Adder` (جمع‌کننده), `Subtractor` (تفریق‌کننده), `Shifter` (شیفت‌دهنده) و `Comparator` (مقایسه‌کننده)[cite: 2].
* [cite_start]**#Memory (حافظه)**: اجزای حافظه مانند `D Flip-Flop` (فلیپ‌فلاپ D), `Register` (رجیستر), `RAM` (حافظه دسترسی تصادفی) و `ROM` (حافظه فقط خواندنی)[cite: 2].
* [cite_start]**#I/O (ورودی/خروجی)**: شامل اجزای ورودی/خروجی[cite: 2].
* [cite_start]**سایر کتابخانه‌ها**: شامل `TTL`, `TCL`, `Base`, `BFH-Praktika`, `Input/Output-Extra` و `Soc` که می‌توانند اجزای تخصصی‌تر و از پیش تعریف شده را ارائه دهند[cite: 2].

### ۱.۲. تنظیمات و نوار ابزار
* **تنظیمات شبیه‌سازی**:
    * [cite_start]`gateUndefined` روی `ignore` تنظیم شده است، به این معنی که حالت‌های تعریف‌نشده گیت‌ها در شبیه‌سازی نادیده گرفته می‌شوند[cite: 2, 3].
    * [cite_start]`simlimit` روی `1000` تنظیم شده است که احتمالا حداکثر تعداد گام‌های شبیه‌سازی را تعیین می‌کند[cite: 2].
    * [cite_start]`simrand` روی `0` تنظیم شده است که به شبیه‌سازی تصادفی مربوط می‌شود[cite: 3].
* **نقشه‌های کلیدی (Key Mappings)**: ابزارهای مختلف Logisim به دکمه‌های ماوس نگاشت شده‌اند. [cite_start]به عنوان مثال، `Button2` (کلیک وسط) به `Poke Tool` و `Button3` (کلیک راست) به `Menu Tool` اختصاص داده شده است[cite: 3].
* [cite_start]**نوار ابزار (Toolbar)**: نوار ابزار دسترسی سریع به ابزارهای پرکاربرد مانند `Poke Tool`، `Edit Tool`، `Wiring Tool`، `Text Tool`، پین‌های ورودی/خروجی، گیت‌های منطقی، و رجیسترها را فراهم می‌کند[cite: 3, 4].

---

## ۲. مدارهای اصلی (Circuits) تعریف شده

فایل پروژه شامل چندین مدار (Circuit) است که هر کدام وظیفه‌ای خاص را در یک پردازنده شبیه‌سازی می‌کنند. [cite_start]مدار `DataPathROM` به عنوان مدار اصلی (main) پروژه تعیین شده است[cite: 2].

### ۲.۱. DataPathROM (مسیر داده با حافظه فقط خواندنی)
[cite_start]این مدار اصلی‌ترین بخش پروژه ماست و اجزای مختلف یک مسیر داده‌ی پردازنده را به هم متصل می‌کند[cite: 987, 988, 989].
* [cite_start]**تونل‌ها (Tunnels)**: برای انتقال سیگنال‌ها با نام‌های مشخص مانند `RS1T`, `immselect`, `ALUop`, `ZeroFlagg`, `CLKT`, `OutPutT`, `rs1`, `rs2`, `rdi` استفاده می‌شوند[cite: 5, 6, 7, 8, 9, 10, 11, 15, 16]. این تونل‌ها خوانایی نمودار مدار را افزایش می‌دهند.
* [cite_start]**پین (Pin)**: برای ورودی و خروجی نهایی مدار، مثل `Result` که خروجی نهایی 32 بیتی را نمایش می‌دهد[cite: 9, 520, 990].
* [cite_start]**کلاک (Clock)**: برای تولید پالس ساعت جهت همگام‌سازی اجزای ترتیبی مدار استفاده می‌شود[cite: 8].
* [cite_start]**جداکننده (Splitter)**: برای تقسیم یک سیگنال چند بیتی به سیگنال‌های کوچکتر یا ترکیب چند سیگنال کوچکتر به یک باس بزرگتر به کار می‌رود[cite: 11, 12, 13, 14].
* [cite_start]**ثابت (Constant)**: برای تولید مقادیر ثابت هگزادسیمال (مثال: `0x2` یا `0x0`) استفاده می‌شود[cite: 7, 15].
* [cite_start]**درگاه AND (AND Gate)**: برای انجام عملیات منطقی AND به کار می‌رود[cite: 17].
* [cite_start]**انتخاب‌گر بیت (BitSelector)**: برای انتخاب گروهی از بیت‌ها از یک ورودی چند بیتی استفاده می‌شود[cite: 17].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب یکی از چندین ورودی بر اساس یک سیگنال انتخاب‌گر به کار می‌رود[cite: 17].
* [cite_start]**شیفت‌دهنده (Shifter)**: برای انجام عملیات شیفت منطقی یا حسابی (مثال: `lr` برای شیفت منطقی به راست) استفاده می‌شود[cite: 17, 18].
* [cite_start]**RAM (حافظه دسترسی تصادفی)**: یک ماژول حافظه قابل خواندن و نوشتن با عرض داده 32 بیت است[cite: 18].
* [cite_start]**کامپوننت‌های فرعی (Sub-Circuits)**: این مدار به چندین مدار فرعی دیگر متصل است که هر یک وظیفه‌ی خاصی را بر عهده دارند: `RegisterFile` (فایل رجیستر), `ControlLogicROM` (منطق کنترل ROM), `ALU` (واحد حساب و منطق), `Zeroflag` (پرچم صفر), `LoadCrtl` (کنترل بارگذاری), `IMM` (مولد مقادیر ثابت) و `PC` (شمارنده برنامه)[cite: 18, 19].

### ۲.۲. PC (Program Counter - شمارنده برنامه)
[cite_start]این مدار مسئول نگهداری آدرس دستورالعمل فعلی و تولید آدرس دستورالعمل بعدی است[cite: 592, 593, 594, 595, 596, 597, 598, 599, 600, 601].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `Clk` (کلاک) [cite: 27, 350, 612][cite_start], `Boffset` (آفست شاخه) [cite: 29, 700] [cite_start]و `PCsrc` (کنترل‌کننده انتخاب منبع PC) [cite: 29, 740] [cite_start]و خروجی `outInstruction` (دستورالعمل خروجی) [cite: 26] را دارد.
* [cite_start]**رجیستر (Register)**: یک رجیستر 32 بیتی برای نگهداری مقدار PC استفاده می‌شود[cite: 30, 31, 570].
* [cite_start]**جمع‌کننده (Adder)**: برای افزایش مقدار PC به اندازه‌ی 4 (برای دستورالعمل‌های متوالی) یا اضافه کردن آفست شاخه به کار می‌رود[cite: 30, 910].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب مقدار بعدی PC، که می‌تواند حاصل افزایش PC یا آدرس هدف یک شاخه باشد، استفاده می‌شود[cite: 29, 30, 760].
* [cite_start]**IM (حافظه دستورالعمل)**: این بخش به یک ماژول حافظه دستورالعمل (`IM`) متصل است که دستورالعمل‌ها را از آدرس PC خوانده و خروجی می‌دهد[cite: 31].

### ۲.۳. RegisterFile (فایل رجیستر)
[cite_start]این مدار 32 رجیستر 32 بیتی (مانند `x0` تا `x31` در RISC-V) را شبیه‌سازی می‌کند و امکان خواندن از دو رجیستر و نوشتن در یک رجیستر را فراهم می‌آورد[cite: 716, 717].
* [cite_start]**پین‌ها (Pins)**: ورودی‌هایی برای آدرس‌های خواندن (`rsi1` [cite: 32, 100][cite_start], `rsi2` [cite: 33, 100][cite_start])، آدرس نوشتن (`rdi` [cite: 33, 100][cite_start])، داده‌ی ورودی برای نوشتن (`rd` [cite: 34, 100][cite_start])، سیگنال فعال‌سازی نوشتن (`we` [cite: 34, 100][cite_start]) و کلاک (`Clk` [cite: 34, 100]) دارد. [cite_start]همچنین دو خروجی 32 بیتی برای داده‌های خوانده شده (`rs1` [cite: 44, 1100][cite_start], `rs2` [cite: 45, 1100]) ارائه می‌دهد.
* [cite_start]**رجیسترها (Registers)**: هر رجیستر به عنوان یک جزء `Register` با لیبل‌های `x0` [cite: 129, 290] [cite_start]تا `x31` [cite: 137, 760] تعریف شده است.
* [cite_start]**دیمالتی‌پلکسر (Demultiplexer)**: برای هدایت سیگنال `WE` (Write Enable) به رجیستر صحیح بر اساس آدرس نوشتن (`rdi`) استفاده می‌شود[cite: 127, 960, 758].
* [cite_start]**مالتی‌پلکسرها (Multiplexers)**: دو مالتی‌پلکسر برای انتخاب داده خروجی از رجیسترها بر اساس آدرس‌های خواندن (`rsi1` و `rsi2`) به کار می‌روند[cite: 127, 128, 759].
* [cite_start]**تونل‌ها (Tunnels)**: برای ارتباط داخلی بین پین‌ها و رجیسترهای تکی استفاده می‌شوند[cite: 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127].

### ۲.۴. ALU (Arithmetic Logic Unit - واحد حساب و منطق)
[cite_start]این مدار یک واحد حساب و منطق 32 بیتی را پیاده‌سازی می‌کند که قادر به انجام عملیات مختلف محاسباتی و منطقی است[cite: 628, 629].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `DataA` [cite: 158, 240][cite_start], `DataB` [cite: 158, 240] [cite_start](عملوندها) و `Selecting` [cite: 159, 250] [cite_start](سیگنال انتخاب عملیات) و خروجی `DataD` [cite: 180, 880] (نتیجه عملیات) را دارد.
* [cite_start]**عملگرها**: شامل `Subtractor` (تفریق) [cite: 182, 430][cite_start], `Adder` (جمع) [cite: 182, 430][cite_start], `Shifter` (شیفت به چپ/راست منطقی و حسابی) [cite: 182, 430, 183][cite_start], `Comparator` (مقایسه برای `slt` و `sltu`) [cite: 183, 430][cite_start], `OR Gate` [cite: 181, 440][cite_start], `AND Gate` [cite: 181, 440][cite_start], `XOR Gate` [cite: 181, 450] [cite_start](عملیات منطقی) می‌باشند[cite: 629, 630].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش سیگنال‌های تک بیتی (مثلاً نتیجه مقایسه) به 32 بیت، معمولاً با صفر یا با Sign (مقدار علامت) به کار می‌رود[cite: 172, 490, 173, 490].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب خروجی نهایی ALU بر اساس سیگنال `Selecting` استفاده می‌شود[cite: 182, 770].
* [cite_start]**متن (Text)**: توضیحات مربوط به کدهای انتخاب برای عملیات ALU را نشان می‌دهد (مثال: add 0000, sub 1000, sll 0001 و ...)[cite: 183, 184, 480, 90].
* [cite_start]**Branch (شاخه)**: به یک مدار `Branch` برای بررسی شرایط شاخه متصل است[cite: 184, 620].

### ۲.۵. Branch (مدار شاخه)
[cite_start]این مدار برای مقایسه دو مقدار و تولید سیگنال `brEq` (برابر بودن شاخه) استفاده می‌شود[cite: 704].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `DataA` [cite: 188, 120][cite_start], `DataB` [cite: 188, 120] [cite_start]و خروجی `brEq` [cite: 191, 850] را دارد.
* [cite_start]**مقایسه‌کننده (Comparator)**: برای مقایسه `DataA` و `DataB` به کار می‌رود[cite: 191, 370].

### ۲.۶. IMM (Immediate Generator - مولد مقدار ثابت)
[cite_start]این مدار برای تولید مقادیر ثابت (immediate values) از دستورالعمل‌ها، با توجه به فرمت‌های مختلف دستورالعمل‌ها، استفاده می‌شود[cite: 773].
* [cite_start]**پین‌ها (Pins)**: ورودی `selecting` [cite: 195, 110] [cite_start](برای انتخاب نوع ثابت) و `Ins` [cite: 196, 160] [cite_start](دستورالعمل 32 بیتی) و خروجی `imm31_0` [cite: 195, 1110] (مقدار ثابت 32 بیتی) را دارد.
* [cite_start]**جداکننده (Splitter)**: برای استخراج بیت‌های مختلف ثابت از دستورالعمل بر اساس فرمت آن (مانند `Ssplitor`, `Bsplitor`, `Jsplitor`, `Usplitor`, `Isplitor` که ماژول‌های فرعی هستند) به کار می‌رود[cite: 199, 690, 200, 690].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش مقادیر ثابت به 32 بیت با Sign Extend یا Zero Extend استفاده می‌شود[cite: 199, 690].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب مقدار ثابت نهایی بر اساس سیگنال `selecting` به کار می‌رود[cite: 209, 1130].

### ۲.۷. مدارهای Splitter (Rsplitor, Isplitor, Ssplitor, Usplitor, Bsplitor, Jsplitor)
[cite_start]این مدارها، که به عنوان زیرمدار در `IMM` استفاده می‌شوند، وظیفه‌ی **دیکد کردن دستورالعمل‌ها** را بر عهده دارند[cite: 780, 781]. هر یک از آن‌ها برای استخراج بیت‌ها بر اساس فرمت خاصی از دستورالعمل (R-type, I-type, S-type, U-type, B-type, J-type) طراحی شده‌اند.
* [cite_start]**پین ورودی (Pin)**: همگی یک پین ورودی به نام `Instruction` (یا `Instroction` یا `Ins`) با عرض 32 بیت دارند[cite: 213, 160, 220, 240, 227, 230, 234, 120, 239, 280, 247, 290].
* [cite_start]**جداکننده (Splitter)**: هسته‌ی این مدارها یک `Splitter` است که سیگنال 32 بیتی دستورالعمل را بر اساس فرمت خاص آن به گروه‌های بیتی معنی‌دار (مانند opcode, rd, funct3, rs1, rs2, funct7 و بیت‌های مختلف immediate) تقسیم می‌کند و آن‌ها را از طریق پین‌های خروجی مربوطه ارائه می‌دهد[cite: 213, 200, 220, 250, 227, 250, 234, 140, 239, 310, 247, 310].

### ۲.۸. FullAdder (جمع‌کننده کامل)
[cite_start]با توجه به تعاریف پین‌ها و گیت‌های `XOR` و `AND` زیاد، این مدار یک **جمع‌کننده کامل 32 بیتی** یا بیشتر را پیاده‌سازی می‌کند[cite: 1165].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` [cite: 255, 110][cite_start], `B` [cite: 256, 110] [cite_start](بیت‌های عملوندها) و خروجی‌های `Sum` (جمع) [cite: 256] [cite_start]و `Carry Out` (حمل) [cite: 257] را دارد.
* [cite_start]**گیت‌های XOR و AND**: برای پیاده‌سازی منطق جمع و حمل در هر بیت استفاده می‌شوند[cite: 299, 300, 301].
* [cite_start]**جداکننده (Splitter)**: برای تقسیم ورودی‌های چند بیتی (مانند `DataA` و `DataB`) به بیت‌های تکی به کار می‌رود[cite: 271, 350, 272, 350, 286, 680, 287, 680].

### ۲.۹. Test (مدار تست)
[cite_start]این یک مدار تست کوچک به نظر می‌رسد که از یک گیت `AND` با ۷ ورودی و چند گیت `NOT` استفاده می‌کند تا یک سیگنال `beq` (برابر بودن شاخه) را تولید کند[cite: 379, 1040].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `i0T` [cite: 378, 950] [cite_start]تا `i6T` [cite: 377, 950] [cite_start]و `i1T` [cite: 379, 970] [cite_start]تا `i5T` [cite: 378, 970] [cite_start]و خروجی `beq` [cite: 376, 1060] را دارد.
* [cite_start]**گیت NOR (NOR Gate)**: در اینجا یک گیت `AND` [cite: 379, 1040] با ورودی‌های negate شده استفاده شده است.

### ۲.۱۰. ControlLogic (منطق کنترل)
[cite_start]این مدار سیگنال‌های کنترلی را برای `ALU` و سایر بخش‌های مسیر داده بر اساس opcode و funct3/funct7 دستورالعمل تولید می‌کند[cite: 922].
* [cite_start]**پین ورودی (Pin)**: ورودی `Instruction` (دستورالعمل 32 بیتی) را دریافت می‌کند[cite: 384, 590].
* [cite_start]**پین‌های خروجی (Pins)**: خروجی‌هایی مانند `ALUselecting` [cite: 384, 400] [cite_start](برای انتخاب عملیات ALU) و `RegWen` [cite: 382] (فعال‌سازی نوشتن در فایل رجیستر) را تولید می‌کند.
* [cite_start]**جداکننده (Splitter)**: برای دیکد کردن بیت‌های دستورالعمل و استخراج بیت‌های مربوط به opcode و funct به کار می‌رود[cite: 383, 390].
* [cite_start]**گیت‌های AND و OR**: برای پیاده‌سازی منطق ترکیبی که سیگنال‌های کنترلی را تولید می‌کند، استفاده می‌شوند[cite: 404, 800, 407, 990, 404].
* [cite_start]**تونل‌ها (Tunnels)**: برای سیگنال‌های داخلی مانند `A0T` [cite: 380, 1000] [cite_start]تا `A3T` [cite: 383, 390] [cite_start](برای ALU selecting) و `addT` [cite: 381, 1150][cite_start], `subT` [cite: 381, 1150][cite_start], `orT` [cite: 380, 1140][cite_start], `andT` [cite: 381, 1150][cite_start], `i2T` [cite: 385, 620] [cite_start]تا `i6T` [cite: 386, 620] (برای بیت‌های opcode/funct) به کار می‌روند.

### ۲.۱۱. DataPath (مسیر داده - یک مدار ساده‌تر)
[cite_start]این مدار یک نمای کلی و ساده‌تر از مسیر داده را نشان می‌دهد و شامل اجزای اصلی مانند `ALU`, `Rsplitor`, `RegisterFile` و `ControlLogic` است[cite: 415].
* [cite_start]**پین‌ها (Pins)**: ورودی `Constant` [cite: 416, 130] [cite_start]و `Clock` [cite: 416, 160] [cite_start]و خروجی `Outt` [cite: 415, 1170] را دارد.
* **اتصالات (Wires)**: سیم‌ها نشان می‌دهند که چگونه این ماژول‌ها برای تشکیل یک مسیر داده اولیه به هم متصل شده‌اند و جریان سیگنال بین آن‌ها چگونه است.

### ۲.۱۲. ControlLogicROM (منطق کنترل بر اساس ROM)
[cite_start]این مدار از یک `ROM` برای تولید سیگنال‌های کنترلی استفاده می‌کند که یک روش رایج برای پیاده‌سازی واحد کنترل است[cite: 922].
* [cite_start]**پین‌ها (Pins)**: ورودی `Instruction` (دستورالعمل) [cite: 425, 590] [cite_start]و خروجی‌هایی مانند `immSelect` [cite: 422, 430] [cite_start](انتخاب نوع ثابت), `ALUselecting` [cite: 423, 470] [cite_start](انتخاب عملیات ALU), `RegWen` [cite: 424, 480] [cite_start](فعال‌سازی نوشتن در رجیستر), `Bselect` [cite: 424, 480] [cite_start](انتخاب شاخه), `WEmem` [cite: 418, 1070] [cite_start](فعال‌سازی نوشتن در حافظه) و `BEQ` [cite: 419, 1100] (سیگنال شاخه برابر) را دارد.
* [cite_start]**ROM (حافظه فقط خواندنی)**: یک ROM با عرض آدرس ۹ بیت و عرض داده ۱۳ بیت، که محتوای آن سیگنال‌های کنترلی را بر اساس بیت‌های دستورالعمل تعیین می‌کند[cite: 445, 710, 967].
* [cite_start]**جداکننده (Splitter)**: برای استخراج بیت‌های دستورالعمل که به عنوان آدرس ورودی ROM استفاده می‌شوند، به کار می‌رود[cite: 422, 430].
* [cite_start]**تونل‌ها (Tunnels)**: برای ارتباط داخلی و خارجی استفاده می‌شوند[cite: 419, 400, 420, 410, 421, 410, 422, 410, 424, 510, 425, 510].

### ۲.۱۳. ALUCtl (کنترل‌کننده ALU)
این مدار برای انتخاب ورودی B به ALU استفاده می‌شود، که می‌تواند از `rs2` یا `immediate` باشد.
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `rs2` [cite: 448, 580][cite_start], `imm31_0` [cite: 449, 580] [cite_start](مقدار ثابت) و `Bselect` [cite: 449, 580] [cite_start](انتخاب‌گر) و خروجی `DataB` [cite: 449, 700] (ورودی نهایی B برای ALU) را دارد.
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: بر اساس `Bselect`، یکی از ورودی‌ها (`rs2` یا `imm31_0`) را به `DataB` هدایت می‌کند[cite: 450, 660].

### ۲.۱۴. LoadByte (بارگذاری بایت)
این مدار عملیات بارگذاری یک بایت را از حافظه شبیه‌سازی می‌کند، و قابلیت بارگذاری بایت علامت‌دار و بدون علامت را دارد.
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` [cite: 452, 500] [cite_start](آدرس), `lw` [cite: 452, 500] [cite_start](داده‌ی خوانده شده از حافظه) و خروجی‌های `LoadB` [cite: 456, 860] [cite_start](بایت علامت‌دار) و `LoadBU` [cite: 457, 920] (بایت بدون علامت) را دارد.
* [cite_start]**جداکننده بیت (BitSelector)**: برای استخراج بایت مورد نظر از کلمه‌ی 32 بیتی به کار می‌رود[cite: 458, 530].
* [cite_start]**شیفت‌دهنده (Shifter)**: برای شیفت بایت به مکان صحیح در کلمه‌ی 32 بیتی استفاده می‌شود[cite: 458, 480].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش بایت به 32 بیت با Sign Extend یا Zero Extend به کار می‌رود[cite: 455, 800].

### ۲.۱۵. Loadhalf (بارگذاری نیم‌کلمه)
این مدار شبیه به LoadByte است، اما برای بارگذاری یک نیم‌کلمه (16 بیت) از حافظه طراحی شده است.
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` [cite: 462, 220] [cite_start](آدرس), `lw` [cite: 462, 220] [cite_start](داده‌ی خوانده شده از حافظه) و خروجی‌های `LoadH` [cite: 465, 440] [cite_start](نیم‌کلمه‌ی علامت‌دار) و `LoadHU` [cite: 466, 500] (نیم‌کلمه‌ی بدون علامت) را دارد.
* [cite_start]**جداکننده بیت (BitSelector)**: برای استخراج نیم‌کلمه‌ی مورد نظر به کار می‌رود[cite: 466, 280].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش نیم‌کلمه به 32 بیت استفاده می‌شود[cite: 463, 340, 464, 340].

### ۲.۱۶. LoadCrtl (کنترل بارگذاری)
[cite_start]این مدار عملیات بارگذاری نهایی را مدیریت می‌کند و داده‌ی خوانده شده از حافظه را بر اساس نوع بارگذاری (بایت، نیم‌کلمه، کلمه) و علامت‌دار/بدون علامت بودن آن، انتخاب و به خروجی می‌دهد[cite: 832, 833].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` [cite: 468, 210] [cite_start](آدرس), `lw` [cite: 468, 210] [cite_start](داده‌ی خوانده شده از حافظه), `lSelect` [cite: 469, 210] [cite_start](انتخاب نوع بارگذاری) و `wbselect` [cite: 469, 210] [cite_start](انتخاب نهایی) و خروجی `Data` [cite: 478, 910] (داده‌ی نهایی بارگذاری شده) را دارد.
* [cite_start]**مالتی‌پلکسرها (Multiplexers)**: برای انتخاب بین خروجی‌های `LoadByte`, `Loadhalf` و داده‌ی کامل (word) استفاده می‌شوند[cite: 478, 670, 478, 800].
* [cite_start]**کامپوننت‌های فرعی**: از ماژول‌های `LoadByte` [cite: 478, 740] [cite_start]و `Loadhalf` [cite: 478, 740] استفاده می‌کند.

### ۲.۱۷. IM (Instruction Memory - حافظه دستورالعمل)
[cite_start]این مدار یک ROM (حافظه فقط خواندنی) است که دستورالعمل‌های برنامه را ذخیره می‌کند و بر اساس آدرس ورودی، دستورالعمل مربوطه را خروجی می‌دهد[cite: 1095, 1096].
* [cite_start]**پین‌ها (Pins)**: ورودی `ADDR` [cite: 480, 400, 1102] [cite_start](آدرس دستورالعمل) و خروجی 32 بیتی (دستورالعمل) [cite: 483, 910, 1151] را دارد.
* [cite_start]**ROM (حافظه فقط خواندنی)**: یک `ROM` با عرض آدرس 16 بیت و عرض داده 32 بیت است[cite: 484, 580, 1098, 1099, 1100, 1103].

### ۲.۱۸. Zeroflag (پرچم صفر)
[cite_start]این مدار یک پرچم `Zero` را تولید می‌کند که نشان می‌دهد آیا نتیجه‌ی یک عملیات صفر است یا خیر[cite: 1009, 1060].
* [cite_start]**پین ورودی (Pin)**: `inputZero` [cite: 486, 330] (مقدار 32 بیتی ورودی برای بررسی صفر بودن) را دارد.
* [cite_start]**گیت NOR (NOR Gate)**: یک گیت NOR [cite: 487, 660] [cite_start]با ورودی‌های زیاد (32 ورودی در اینجا) می‌تواند برای تشخیص صفر بودن یک کلمه‌ی 32 بیتی استفاده شود[cite: 487]. اگر همه‌ی بیت‌ها صفر باشند، خروجی NOR برابر با 1 (صفر بودن) خواهد بود.

---

## ۳. نتیجه‌گیری

مدارهای تعریف‌شده در فایل پروژه، یک شبیه‌سازی جامع و ماژولار از بخش‌های کلیدی یک مسیر داده‌ی پردازنده را در Logisim-evolution ارائه می‌دهند. از واحدهایی مانند Program Counter، فایل رجیستر، ALU و حافظه دستورالعمل گرفته تا کنترل‌کننده‌های پیچیده‌تر برای تولید مقادیر ثابت و مدیریت عملیات بارگذاری، همه به دقت مدل‌سازی شده‌اند. این طراحی ماژولار امکان تست و دیباگ هر بخش را به صورت جداگانه فراهم می‌کند و سپس آن‌ها را در یک سیستم کامل یکپارچه می‌سازد. پروژه ما نه تنها به درک عمیق‌تر معماری کامپیوتر کمک می‌کند، بلکه نشان‌دهنده توانایی‌های Logisim-evolution در طراحی و شبیه‌سازی سیستم‌های دیجیتال پیچیده است.

[cite_start]**نکته پایانی:** برای طراحی این مدار روزهای زیادی وقت گذاشته شد و باعث شد ما به مهارت‌های ارزشمندی دست پیدا کنیم[cite: 1161]. [cite_start]ما در مسیر طراحی این پردازنده با معماری RISC-V به باگ‌های زیادی برخورد کردیم که بعضی از آن‌ها بسیار وقت‌گیر بودند[cite: 1167]. [cite_start]به عنوان مثال، مشکل از آدرس‌دهی RAM برای ذخیره‌سازی بود و یا باگ‌های نحوی (اشتباه بودن نام تونل‌ها) که باعث چالش‌های زیادی شد[cite: 1167]. [cite_start]همچنین برای تست این مدار، یک اسمبلر کوچک برای هر دو معماری RISC-V و MIPS طراحی کردیم تا کدهای دستوری را به کد Hexadecimal تبدیل و آماده تست کنیم[cite: 1168]. [cite_start]این برنامه تا جایی که شد، به فاصله سه روز تا ارائه پروژه طراحی و بهینه‌سازی شد[cite: 1169].

---

Created By - Nima Ghaffari & Parsa Zandi

---

<p align="left">
  <a href="https://t.me/nimaghaffari001" style="margin-right: 10px;">
    <img src="https://img.shields.io/badge/Private%20Message-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram PV">
  </a>
  
  <a href="https://t.me/CallMeNiMChe">
    <img src="https://img.shields.io/badge/Telegram%20Channel-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Channel">
  </a>
</p>

---