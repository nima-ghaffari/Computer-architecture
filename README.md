<div dir="rtl">

# راهنمای جامع پروژه پردازنده RISC-V 32 بیتی در Logisim-evolution

در این سند راهنما، به تشریح جزئیات طراحی و پیاده‌سازی یک پردازنده ۳۲ بیتی مبتنی بر **معماری RISC-V** در نرم‌افزار Logisim-evolution می‌پردازیم. هدف اصلی این پروژه، **درک عمیق‌تر مفاهیم معماری رایانه و سیستم‌های دیجیتال** از طریق ساخت یک هسته پردازنده RV32 است که شامل پیاده‌سازی ۴۰ دستورالعمل پایه می‌شود. این راهنما برای دانشجویان، پژوهشگران و تمامی علاقه‌مندان به معماری کامپیوتر که مایل به آشنایی با ساختار و عملکرد یک پردازنده RISC-V هستند، تدوین شده است [15].

Logisim-evolution به عنوان ابزاری قدرتمند، آموزشی و بصری، امکان طراحی، شبیه‌سازی و آزمایش مدارهای منطقی را به شیوه‌ای تعاملی و گرافیکی فراهم می‌آورد [17, 18]. این نرم‌افزار محیطی ایده‌آل برای تجربه عملی مفاهیم پیچیده مانند مسیر داده، کنترل جریان و تعامل میان مؤلفه‌های پردازنده ارائه می‌دهد [18].

---

### ۱. ساختار پروژه و کتابخانه‌های مورد استفاده

پروژه ما در Logisim-evolution نسخه‌ی 3.9.0 توسعه یافته است و شامل مجموعه‌ای از مدارهای منطقی ماژولار است که هر یک وظیفه‌ای مشخص را در مسیر داده‌ی پردازنده انجام می‌دهند. برای این منظور، ما از کتابخانه‌های استاندارد Logisim-evolution بهره گرفته‌ایم [681]:

* **Wiring (سیم‌کشی)**: شامل ابزارهای پایه‌ای نظیر `Splitter` برای جداسازی یا ترکیب باس‌ها، `Pin` برای ورودی و خروجی مدار، و `Tunnel` برای اتصالات سیگنال‌ها در فواصل دور جهت افزایش خوانایی نمودار مدار [682].
* **Gates (گیت‌ها)**: مجموعه‌ای از گیت‌های منطقی پایه شامل `AND`, `OR`, `NOT`, `XOR`, `NAND`, `NOR` [684].
* **Plexers (مالتی‌پلکسرها)**: برای انتخاب و هدایت سیگنال‌ها، شامل `Multiplexer` و `Demultiplexer` [697, 808].
* **Arithmetic (محاسبات)**: اجزای انجام عملیات ریاضی و منطقی مانند `Adder`, `Subtractor`, `Shifter` و `Comparator` [698, 862, 863].
* **Memory (حافظه)**: شامل اجزای حافظه نظیر `D Flip-Flop`, `Register`, `RAM` (حافظه دسترسی تصادفی) و `ROM` (حافظه فقط خواندنی) [698, 711, 809, 1164].
* **I/O (ورودی/خروجی)**: برای تعامل با محیط بیرونی مدار [682].
* **سایر کتابخانه‌ها**: شامل `TTL`, `TCL`, `Base`, `BFH-Praktika`, `Input/Output-Extra` و `Soc` که اجزای تخصصی‌تر و از پیش تعریف شده را فراهم می‌آورند [682].

تنظیمات شبیه‌سازی در Logisim-evolution شامل `gateUndefined` (تنظیم شده بر روی `ignore`)، `simlimit` (محدودیت ۱۰۰۰ گام شبیه‌سازی) و `simrand` (تنظیم شده بر روی `0`) است [682, 683]. همچنین، ابزارهای پرکاربرد از طریق نوار ابزار اصلی (شامل `Poke Tool`، `Edit Tool`، `Wiring Tool`، `Text Tool`) و نقشه‌های کلیدی (مانند `Poke Tool` و `Menu Tool` برای کلیک‌های ماوس) در دسترس ما قرار گرفته‌اند [683, 684].

---

### ۲. مروری بر مدارهای اصلی

پروژه ما شامل چندین مدار اصلی است که هر کدام وظیفه‌ای حیاتی در عملکرد پردازنده RISC-V دارند. مدار `DataPathROM` به عنوان مدار اصلی (main) این پروژه عمل می‌کند و اجزای زیر را در خود جای داده است [684, 685]:

#### ۲.۱. Program Counter (PC - شمارنده برنامه)

این مدار یکی از اصلی‌ترین ثبات‌ها در هر معماری پردازنده است [101] و در معماری RISC-V، نقش حیاتی در **کنترل جریان اجرای برنامه** دارد [102]. PC آدرس دستورالعملی که باید در چرخه بعدی CPU اجرا شود، نگهداری می‌کند [102]. وظایف اصلی PC شامل نگهداری آدرس دستور فعلی، افزایش آدرس به صورت ترتیبی (معمولاً ۴ بایت برای دستورالعمل‌های ۳۲ بیتی) و انجام پرش‌ها یا انشعابات است که منجر به تغییر غیرخطی در آدرس PC می‌شود [108, 109, 110]. PC در طراحی ما شامل یک رجیستر ۳۲ بیتی برای نگهداری مقدار PC، یک جمع‌کننده برای افزایش PC و یک مالتی‌پلکسر برای انتخاب بین آدرس افزایش‌یافته و آدرس پرش/انشعاب است [710, 760].

#### ۲.۲. Arithmetic Logic Unit (ALU - واحد حساب و منطق)

ALU قلب هر پردازنده است و وظیفه‌ی **انجام عملیات‌های ریاضی و منطقی** را بر عهده دارد [137]. ALU در معماری RISC-V قادر به انجام انواع دستورها مانند جمع، تفریق، OR, AND، شیفت بیت‌ها و مقایسه‌هاست [138]. این واحد ورودی‌های خود را از رجیسترها دریافت کرده و نتیجه را نیز در رجیستری ذخیره می‌کند [138]. عملیات‌های ALU بر اساس یک سیگنال `Selecting` چهار بیتی انتخاب می‌شوند [200, 216]. در طراحی ما، ماژول‌های جداگانه‌ای برای هر عملیات (جمع‌کننده، تفریق‌کننده، شیفت‌دهنده‌ها و مقایسه‌گرها) ساخته شده و خروجی آن‌ها از طریق یک مالتی‌پلکسر واحد به خروجی نهایی ALU (`DataD`) هدایت می‌شود [202, 211, 215, 216]. همچنین، یک بخش مقایسه (Branch) برای تشخیص برابری (BEQ) در ALU وجود دارد [213].

#### ۲.۳. Register File (فایل رجیستر)

Register File یک ماژول حیاتی برای **ذخیره‌سازی موقت داده‌ها** جهت انجام سریع عملیات‌های پردازشی است [225]. این فایل شامل ۳۲ رجیستر (از `x0` تا `x31`) است که امکان خواندن از دو رجیستر به صورت همزمان (`rs1` و `rs2`) و نوشتن در یک رجیستر (`rd`) را فراهم می‌آورد [225, 266, 268]. عملیات نوشتن از طریق سیگنال `Write Enable (WE)` و یک `Demultiplexer` صورت می‌گیرد که تنها رجیستر مورد نظر را در لبه ساعت فعال می‌کند [267, 271]. دو مالتی‌پلکسر بزرگ نیز برای انتخاب خروجی‌های خواندن (`rsi1T` و `rsi2T`) بر اساس آدرس‌های ورودی مربوطه استفاده می‌شوند [275, 276].

#### ۲.۴. Immediate Generator (IMM - مولد مقدار ثابت)

این مدار مسئول **استخراج و گسترش مقادیر ثابت (Immediate)** از دستورالعمل‌ها، بسته به نوع فرمت دستور (مانند I-type, S-type, B-type و U-type) است [282, 289]. این مقادیر پس از استخراج توسط ماژول‌های `Splitter` (شامل `Isplitor`, `Ssplitor`, `Bsplitor`, `Jsplitor`, `Usplitor` که ماژول‌های فرعی هستند)، به اندازه‌ی ۳۲ بیت `Sign Extend` یا `Zero Extend` می‌شوند [293]. در نهایت، توسط یک `Multiplexer` بر اساس سیگنال `SelectingT` به خروجی نهایی (`imm31_0T`) هدایت می‌شوند [296, 297].

#### ۲.۵. Load Control (LoadCrtl)

واحد LoadCtrl مسئول **مدیریت خواندن داده‌های مختلف** (بایت، نیم‌کلمه، کلمه کامل) از حافظه (RAM) و تبدیل آن‌ها بر حسب نیاز دستورالعمل است [341]. این ماژول قابلیت انتخاب نوع داده‌ی بارگذاری شونده (امضادار یا بدون امضا) را نیز بر عهده دارد [341]. LoadCtrl به عنوان واسط اصلی میان پردازنده و حافظه‌ی عملیاتی، نقش مهمی در بارگذاری صحیح و انعطاف‌پذیر داده‌ها ایفا می‌کند [342]. این مدار با ترکیب مالتی‌پلکسرهای انتخاب نوع داده، اسپلیترها و اتصال مستقیم به RAM کارآیی و دقت لازم برای بارگذاری انواع مختلف داده را تأمین می‌کند [343].

#### ۲.۶. Control Unit (ROM)

واحد کنترل، به عنوان **قلب فرماندهی پردازنده**، بر اساس کد دستورالعمل ورودی، سیگنال‌های کنترلی مورد نیاز برای ماژول‌های مختلف (ALU، رجیستر فایل، حافظه و غیره) را تولید می‌کند [431]. در طراحی ما، این واحد با استفاده از یک `ROM` پیاده‌سازی شده است که بیت‌های خاصی از دستورالعمل (مانند فانکشن و آپ‌کد) به عنوان آدرس به آن داده می‌شوند [431, 473]. هر آدرس در ROM، مجموعه‌ای از سیگنال‌های کنترلی را ذخیره کرده است که فعال/غیرفعال‌سازی و انتخاب عملکرد بخش‌های مختلف پردازنده (شامل فعال‌سازی نوشتن در رجیستر، انتخاب باس‌ها یا مسیرهای داده، انتخاب داده برای نوشتن در رجیسترها، انتخاب نوع بارگذاری و فعال‌سازی نوشتن در حافظه داده) را تعیین می‌کنند [476, 477, 480].

#### ۲.۷. Instruction Memory (IM - حافظه دستورالعمل)

در این بخش از طراحی پردازنده، یک واحد `ROM` با ظرفیت ۶۴K کلمه (۲ به توان ۱۶ آدرس) و طول هر کلمه ۳۲ بیت به عنوان **حافظه دستورالعمل** مورد استفاده قرار گرفته است [604, 607, 608]. این حافظه وظیفه‌ی نگهداری و ارائه‌ی دستورالعمل‌ها به واحد کنترل را بر عهده دارد [605]. آدرس ۱۶ بیتی از `Program Counter (PC)` به این `ROM` داده می‌شود و `ROM` نیز دستورالعمل ۳۲ بیتی ذخیره شده در آن آدرس را به عنوان خروجی ارائه می‌دهد [652, 656, 660, 665, 666]. این ماژول نقش کلیدی در فرآیند **واکشی دستورالعمل (Instruction Fetch)** دارد [668].

#### ۲.۸. Zeroflag (پرچم صفر)

این مدار، یک **پرچم `Zero`** را تولید می‌کند که نشان‌دهنده‌ی صفر بودن نتیجه‌ی یک عملیات است [1167]. این عمل با استفاده از یک `NOR Gate` با ۳۲ ورودی انجام می‌شود [1167]. اگر تمام بیت‌های ورودی صفر باشند، خروجی `NOR Gate` مقدار ۱ (نشان‌دهنده‌ی صفر بودن) خواهد بود.

---

### ۳. نکات پایانی و تجربیات ما

طراحی مدارهای این پروژه، یک شبیه‌سازی جامع و ماژولار از بخش‌های کلیدی یک مسیر داده‌ی پردازنده را در Logisim-evolution ارائه می‌دهد. از واحدهایی مانند Program Counter، فایل رجیستر، ALU و حافظه دستورالعمل گرفته تا کنترل‌کننده‌های پیچیده‌تر برای تولید مقادیر ثابت و مدیریت عملیات بارگذاری، همه به دقت مدل‌سازی شده‌اند. این طراحی ماژولار امکان تست و دیباگ هر بخش را به صورت جداگانه فراهم می‌کند و سپس آن‌ها را در یک سیستم کامل یکپارچه می‌سازد. پروژه ما نه تنها به درک عمیق‌تر معماری کامپیوتر کمک می‌کند، بلکه نشان‌دهنده توانایی‌های Logisim-evolution در طراحی و شبیه‌سازی سیستم‌های دیجیتال پیچیده است.

برای طراحی این مدار روزهای زیادی وقت گذاشته شد و باعث شد ما به مهارت‌های ارزشمندی دست پیدا کنیم [670]. ما در مسیر طراحی این پردازنده با معماری RISC-V به باگ‌های زیادی برخورد کردیم که بعضی از آن‌ها بسیار وقت‌گیر بودند [676]. به عنوان مثال، مشکل از آدرس‌دهی RAM برای ذخیره‌سازی بود و یا باگ‌های نحوی (مانند اشتباه بودن نام تونل‌ها) که باعث چالش‌های زیادی شد [676]. همچنین برای تست این مدار، یک اسمبلر کوچک برای هر دو معماری RISC-V و MIPS طراحی کردیم تا کدهای دستوری را به کد Hexadecimal تبدیل و آماده تست کنیم [677]. این برنامه تا جایی که شد، به فاصله سه روز تا ارائه پروژه طراحی و بهینه‌سازی شد [678].

---

**تیم پروژه:**

* **نیما غفاری**
* **پارسا زندی**

---

<p align="left">
  <a href="https://t.me/nimaghaffari001" style="margin-right: 10px;">
    <img src="https://img.shields.io/badge/Private%20Message-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram PV">
  </a>
  <a href="https://t.me/CallMeNiMChe">
    <img src="https://img.shields.io/badge/Telegram%20Channel-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Channel">
  </a>
</p>

---
</div>