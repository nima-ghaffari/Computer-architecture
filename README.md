# راهنمای جامع مدارهای Logisim-evolution (بر اساس فایل `fin.txt`)

این سند به تشریح کامل مدارهای طراحی شده در نرم‌افزار Logisim-evolution، که از فایل `fin.txt` استخراج شده‌اند، می‌پردازد. این مدارها هسته‌ی یک مسیر داده (Datapath) پردازنده را تشکیل می‌دهند و به منظور شبیه‌سازی عملکرد بخش‌های مختلف یک CPU طراحی شده‌اند. [cite_start]این پروژه توسط Logisim-evolution نسخه‌ی 3.9.0 توسعه یافته است، که نسخه‌ی پیشرفته‌تر و متن‌باز Logisim اصلی است و قابلیت‌های بیشتری برای طراحی و تحلیل مدارهای منطقی دیجیتال ارائه می‌دهد[cite: 1].

---

## ۱. ساختار فایل پروژه و کتابخانه‌ها

[cite_start]فایل `fin.txt` یک فایل پروژه Logisim-evolution است که علاوه بر تعاریف مدارها، شامل تنظیمات کلی محیط شبیه‌سازی و کتابخانه‌های مورد استفاده نیز می‌باشد[cite: 1, 2].

### ۱.۱. کتابخانه‌های مورد استفاده
[cite_start]در این پروژه، از کتابخانه‌های استاندارد Logisim-evolution استفاده شده است که هر کدام مجموعه‌ای از اجزای پرکاربرد برای ساخت مدارهای دیجیتال را در خود جای داده‌اند[cite: 2]:
* [cite_start]**#Wiring (سیم‌کشی)**: شامل ابزارهای اساسی برای اتصال و مسیریابی سیگنال‌ها مانند `Splitter` (جداکننده بیت‌ها از یک باس یا ترکیب آن‌ها)، `Pin` (پین‌های ورودی و خروجی مدار) و `Tunnel` (برای نامگذاری و اتصال سیگنال‌ها در فواصل دور برای افزایش خوانایی)[cite: 2].
* [cite_start]**#Gates (گیت‌ها)**: حاوی گیت‌های منطقی پایه مانند `AND`, `OR`, `NOT`, `XOR`, `NAND`, `NOR`[cite: 2, 4].
* [cite_start]**#Plexers (مالتی‌پلکسرها)**: شامل `Multiplexer` (انتخاب یکی از چند ورودی) و `Demultiplexer` (هدایت یک ورودی به یکی از چند خروجی)[cite: 2].
* [cite_start]**#Arithmetic (محاسبات)**: اجزای مربوط به عملیات محاسباتی و منطقی نظیر `Adder` (جمع‌کننده), `Subtractor` (تفریق‌کننده), `Shifter` (شیفت‌دهنده) و `Comparator` (مقایسه‌کننده)[cite: 2].
* [cite_start]**#Memory (حافظه)**: اجزای حافظه مانند `D Flip-Flop` (فلیپ‌فلاپ D), `Register` (رجیستر), `RAM` (حافظه دسترسی تصادفی) و `ROM` (حافظه فقط خواندنی)[cite: 2, 4].
* [cite_start]**#I/O (ورودی/خروجی)**: شامل اجزای ورودی/خروجی[cite: 2].
* [cite_start]**سایر کتابخانه‌ها**: شامل `TTL`, `TCL`, `Base`, `BFH-Praktika`, `Input/Output-Extra` و `Soc` که می‌توانند اجزای تخصصی‌تر و از پیش تعریف شده را ارائه دهند[cite: 2].

### ۱.۲. تنظیمات و نوار ابزار
* **تنظیمات شبیه‌سازی**:
    * [cite_start]`gateUndefined` روی `ignore` تنظیم شده است [cite: 2]، به این معنی که حالت‌های تعریف‌نشده گیت‌ها در شبیه‌سازی نادیده گرفته می‌شوند.
    * [cite_start]`simlimit` روی `1000` تنظیم شده است [cite: 2] که احتمالا حداکثر تعداد گام‌های شبیه‌سازی را تعیین می‌کند.
    * [cite_start]`simrand` روی `0` تنظیم شده است [cite: 3] که به شبیه‌سازی تصادفی مربوط می‌شود.
* [cite_start]**نقشه‌های کلیدی (Key Mappings)**: ابزارهای مختلف Logisim به دکمه‌های ماوس نگاشت شده‌اند[cite: 3]. [cite_start]به عنوان مثال، `Button2` (کلیک وسط) به `Poke Tool` و `Button3` (کلیک راست) به `Menu Tool` اختصاص داده شده است[cite: 3].
* [cite_start]**نوار ابزار (Toolbar)**: نوار ابزار دسترسی سریع به ابزارهای پرکاربرد مانند `Poke Tool`، `Edit Tool`، `Wiring Tool`، `Text Tool`، پین‌های ورودی/خروجی، گیت‌های منطقی، و رجیسترها را فراهم می‌کند[cite: 3, 4].

---

## ۲. مدارهای اصلی (Circuits) تعریف شده

[cite_start]فایل `fin.txt` شامل چندین مدار (Circuit) است که هر کدام وظیفه‌ای خاص را در یک پردازنده شبیه‌سازی می‌کنند[cite: 4, 5]. [cite_start]مدار `DataPathROM` به عنوان مدار اصلی (main) پروژه تعیین شده است[cite: 2, 4].

### ۲.۱. DataPathROM (مسیر داده با حافظه فقط خواندنی)
[cite_start]این مدار اصلی‌ترین بخش پروژه است و اجزای مختلف یک مسیر داده‌ی پردازنده را به هم متصل می‌کند[cite: 4, 5].
* [cite_start]**تونل‌ها (Tunnels)**: برای انتقال سیگنال‌ها با نام‌های مشخص مانند `RS1T`, `immselect`, `ALUop`, `ZeroFlagg`, `CLKT`, `OutPutT`, `rs1`, `rs2`, `rdi`[cite: 5, 6, 7, 8, 9, 10, 11, 15, 16]. این تونل‌ها به شدت خوانایی نمودار مدار را افزایش می‌دهند، زیرا نیازی به رسم سیم‌های طولانی در سراسر مدار نیست.
* [cite_start]**پین (Pin)**: برای ورودی و خروجی نهایی مدار، مثل `Result` که خروجی نهایی 32 بیتی را نمایش می‌دهد[cite: 9].
* [cite_start]**کلاک (Clock)**: برای تولید پالس ساعت جهت همگام‌سازی اجزای ترتیبی مدار (مثال: در مختصات (350,320))[cite: 8].
* [cite_start]**جداکننده (Splitter)**: برای تقسیم یک سیگنال چند بیتی به سیگنال‌های کوچکتر (مانند استخراج بیت‌های خاص از یک دستورالعمل 32 بیتی) یا ترکیب چند سیگنال کوچکتر به یک باس بزرگتر[cite: 11, 12, 13, 14].
* [cite_start]**ثابت (Constant)**: برای تولید مقادیر ثابت هگزادسیمال (مثال: `0x2` یا `0x0`)[cite: 7, 15].
* [cite_start]**درگاه AND (AND Gate)**: برای انجام عملیات منطقی AND[cite: 17].
* [cite_start]**انتخاب‌گر بیت (BitSelector)**: برای انتخاب گروهی از بیت‌ها از یک ورودی چند بیتی[cite: 17].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب یکی از چندین ورودی بر اساس یک سیگنال انتخاب‌گر[cite: 17].
* [cite_start]**شیفت‌دهنده (Shifter)**: برای انجام عملیات شیفت منطقی یا حسابی (مثال: `lr` برای شیفت منطقی به راست)[cite: 17, 18].
* [cite_start]**RAM (حافظه دسترسی تصادفی)**: یک ماژول حافظه قابل خواندن و نوشتن با عرض داده 32 بیت[cite: 18].
* [cite_start]**کامپوننت‌های فرعی (Sub-Circuits)**: این مدار به چندین مدار فرعی دیگر متصل است که هر یک وظیفه‌ی خاصی را بر عهده دارند: `RegisterFile` (فایل رجیستر) [cite: 18][cite_start], `ControlLogicROM` (منطق کنترل ROM) [cite: 18][cite_start], `ALU` (واحد حساب و منطق) [cite: 18][cite_start], `Zeroflag` (پرچم صفر) [cite: 18][cite_start], `LoadCrtl` (کنترل بارگذاری) [cite: 18][cite_start], `IMM` (مولد مقادیر ثابت) [cite: 18] [cite_start]و `PC` (شمارنده برنامه)[cite: 19].

### ۲.۲. PC (Program Counter - شمارنده برنامه)
[cite_start]این مدار مسئول نگهداری آدرس دستورالعمل فعلی و تولید آدرس دستورالعمل بعدی است[cite: 25, 26].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `Clk` (کلاک) [cite: 27][cite_start]، `Boffset` (آفست شاخه) [cite: 29] [cite_start]و `PCsrc` (کنترل‌کننده انتخاب منبع PC) [cite: 29] [cite_start]و خروجی `outInstruction` (دستورالعمل خروجی) [cite: 26] را دارد.
* [cite_start]**رجیستر (Register)**: یک رجیستر 32 بیتی برای نگهداری مقدار PC[cite: 30, 31].
* [cite_start]**جمع‌کننده (Adder)**: برای افزایش مقدار PC به اندازه‌ی 4 (برای دستورالعمل‌های متوالی) یا اضافه کردن آفست شاخه[cite: 30].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب مقدار بعدی PC، که می‌تواند حاصل افزایش PC یا آدرس هدف یک شاخه باشد[cite: 29, 30].
* [cite_start]**IM (حافظه دستورالعمل)**: این بخش به یک ماژول حافظه دستورالعمل (`IM`) متصل است که دستورالعمل‌ها را از آدرس PC خوانده و خروجی می‌دهد[cite: 31].

### ۲.۳. RegisterFile (فایل رجیستر)
[cite_start]این مدار 32 رجیستر 32 بیتی (مانند `x0` تا `x31` در RISC-V) را شبیه‌سازی می‌کند و امکان خواندن از دو رجیستر و نوشتن در یک رجیستر را فراهم می‌آورد[cite: 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139].
* [cite_start]**پین‌ها (Pins)**: ورودی‌هایی برای آدرس‌های خواندن (`rsi1`, `rsi2`) [cite: 32, 33][cite_start]، آدرس نوشتن (`rdi`) [cite: 33][cite_start]، داده‌ی ورودی برای نوشتن (`rd`) [cite: 33, 34][cite_start]، سیگنال فعال‌سازی نوشتن (`we`) [cite: 34] [cite_start]و کلاک (`Clk`) [cite: 34] دارد. [cite_start]همچنین دو خروجی 32 بیتی برای داده‌های خوانده شده (`rs1`, `rs2`) ارائه می‌دهد[cite: 44, 45].
* [cite_start]**رجیسترها (Registers)**: هر رجیستر به عنوان یک جزء `Register` با لیبل‌های `x0` تا `x31` تعریف شده است[cite: 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139].
* [cite_start]**دیمالتی‌پلکسر (Demultiplexer)**: برای هدایت سیگنال `WE` (Write Enable) به رجیستر صحیح بر اساس آدرس نوشتن (`rdi`)[cite: 128].
* [cite_start]**مالتی‌پلکسرها (Multiplexers)**: دو مالتی‌پلکسر برای انتخاب داده خروجی از رجیسترها بر اساس آدرس‌های خواندن (`rsi1` و `rsi2`)[cite: 127, 128].
* [cite_start]**تونل‌ها (Tunnels)**: برای ارتباط داخلی بین پین‌ها و رجیسترهای تکی[cite: 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127].

### ۲.۴. ALU (Arithmetic Logic Unit - واحد حساب و منطق)
[cite_start]این مدار یک واحد حساب و منطق 32 بیتی را پیاده‌سازی می‌کند که قادر به انجام عملیات مختلف محاسباتی و منطقی است[cite: 153, 154].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `DataA`, `DataB` (عملوندها) [cite: 158, 159] [cite_start]و `Selecting` (سیگنال انتخاب عملیات) [cite: 159] [cite_start]و خروجی `DataD` (نتیجه عملیات) [cite: 180, 181] را دارد.
* [cite_start]**عملگرها**: شامل `Subtractor` (تفریق) [cite: 182][cite_start], `Adder` (جمع) [cite: 182][cite_start], `Shifter` (شیفت به چپ/راست منطقی و حسابی) [cite: 182, 183][cite_start], `Comparator` (مقایسه برای `slt` و `sltu`) [cite: 183][cite_start], `OR Gate` [cite: 181][cite_start], `AND Gate` [cite: 181][cite_start], `XOR Gate` [cite: 181] (عملیات منطقی).
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش سیگنال‌های تک بیتی (مثلاً نتیجه مقایسه) به 32 بیت، معمولاً با صفر یا با Sign (مقدار علامت)[cite: 172, 173, 178, 179].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب خروجی نهایی ALU بر اساس سیگنال `Selecting`[cite: 181, 182].
* [cite_start]**متن (Text)**: توضیحات مربوط به کدهای انتخاب برای عملیات ALU را نشان می‌دهد (مثال: add 0000, sub 1000, sll 0001 و ...)[cite: 183, 184].
* [cite_start]**Branch (شاخه)**: به یک مدار `Branch` برای بررسی شرایط شاخه متصل است[cite: 184].

### ۲.۵. Branch (مدار شاخه)
[cite_start]این مدار برای مقایسه دو مقدار و تولید سیگنال `brEq` (برابر بودن شاخه) استفاده می‌شود[cite: 187].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `DataA`, `DataB` [cite: 188] [cite_start]و خروجی `brEq` [cite: 191] را دارد.
* [cite_start]**مقایسه‌کننده (Comparator)**: برای مقایسه `DataA` و `DataB`[cite: 191].

### ۲.۶. IMM (Immediate Value Generator - مولد مقدار ثابت)
[cite_start]این مدار برای تولید مقادیر ثابت (immediate values) از دستورالعمل‌ها، با توجه به فرمت‌های مختلف دستورالعمل‌ها، استفاده می‌شود[cite: 191, 192, 193, 194, 195].
* [cite_start]**پین‌ها (Pins)**: ورودی `selecting` (برای انتخاب نوع ثابت) [cite: 195] [cite_start]و `Ins` (دستورالعمل 32 بیتی) [cite: 196] [cite_start]و خروجی `imm31_0` (مقدار ثابت 32 بیتی) [cite: 195] را دارد.
* [cite_start]**جداکننده (Splitter)**: برای استخراج بیت‌های مختلف ثابت از دستورالعمل بر اساس فرمت آن (مانند `Ssplitor`, `Bsplitor`, `Jsplitor`, `Usplitor`, `Isplitor` که ماژول‌های فرعی هستند)[cite: 199, 200, 201, 202, 203].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش مقادیر ثابت به 32 بیت با Sign Extend یا Zero Extend[cite: 199, 207, 208, 209].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب مقدار ثابت نهایی بر اساس سیگنال `selecting`[cite: 209].

### ۲.۷. مدارهای Splitter (Rsplitor, Isplitor, Ssplitor, Usplitor, Bsplitor, Jsplitor)
[cite_start]این مدارها، که به عنوان زیرمدار در `IMM` استفاده می‌شوند، وظیفه‌ی **دیکد کردن دستورالعمل‌ها** را بر عهده دارند[cite: 209, 210]. [cite_start]هر یک از آن‌ها برای استخراج بیت‌ها بر اساس فرمت خاصی از دستورالعمل (R-type, I-type, S-type, U-type, B-type, J-type) طراحی شده‌اند[cite: 213, 214, 215, 216, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253].
* [cite_start]**پین ورودی (Pin)**: همگی یک پین ورودی به نام `Instruction` (یا `Instroction` یا `Ins`) با عرض 32 بیت دارند[cite: 213, 220, 227, 234, 239, 247].
* [cite_start]**جداکننده (Splitter)**: هسته‌ی این مدارها یک `Splitter` است که سیگنال 32 بیتی دستورالعمل را بر اساس فرمت خاص آن به گروه‌های بیتی معنی‌دار (مانند opcode, rd, funct3, rs1, rs2, funct7 و بیت‌های مختلف immediate) تقسیم می‌کند و آن‌ها را از طریق پین‌های خروجی مربوطه ارائه می‌دهد[cite: 213, 214, 215, 216, 220, 221, 222, 223, 227, 228, 229, 230, 234, 235, 236, 239, 240, 241, 242, 247, 248, 249, 250].

### ۲.۸. FullAdder (جمع‌کننده کامل)
[cite_start]با توجه به تعاریف پین‌ها و گیت‌های `XOR` و `AND` زیاد [cite: 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317]، به نظر می‌رسد این مدار یک **جمع‌کننده کامل 32 بیتی** یا بیشتر را پیاده‌سازی می‌کند، نه فقط یک جمع‌کننده 1 بیتی.
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A`, `B` (بیت‌های عملوندها) [cite: 255, 256] [cite_start]و خروجی‌های `Sum` (جمع) و `Carry Out` (حمل) را خواهد داشت[cite: 256, 257, 258, 260, 261, 263, 264, 266, 267, 269, 270, 272, 273, 274]. [cite_start]همچنین پین‌های متعددی برای بیت‌های جداگانه ورودی `A` و `B` (A0 تا A31 و B0 تا B31) دیده می‌شوند که نشان‌دهنده یک طراحی بیتی برای جمع‌کننده است[cite: 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296].
* [cite_start]**گیت‌های XOR و AND**: برای پیاده‌سازی منطق جمع و حمل در هر بیت استفاده می‌شوند[cite: 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317].
* [cite_start]**جداکننده (Splitter)**: برای تقسیم ورودی‌های چند بیتی (مانند `DataA` و `DataB`) به بیت‌های تکی[cite: 272, 286, 287].

### ۲.۹. Test (مدار تست)
[cite_start]این یک مدار تست کوچک به نظر می‌رسد که از یک گیت `AND` با ۷ ورودی و چند گیت `NOT` استفاده می‌کند تا یک سیگنال `beq` (برابر بودن شاخه) را تولید کند[cite: 379]. [cite_start]این مدار احتمالاً برای تست عملکرد `beq` یا بخشی از منطق کنترل مربوط به شاخه‌ها به کار می‌رود[cite: 379].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `i0T` تا `i6T` و `i1T` تا `i5T` و خروجی `beq`[cite: 376, 377, 378, 379].
* [cite_start]**گیت NOR (NOR Gate)**: در اینجا یک گیت `AND` با ورودی‌های negate شده استفاده شده است[cite: 379].

### ۲.۱۰. ControlLogic (منطق کنترل)
[cite_start]این مدار سیگنال‌های کنترلی را برای `ALU` و سایر بخش‌های مسیر داده بر اساس opcode و funct3/funct7 دستورالعمل تولید می‌کند[cite: 380].
* [cite_start]**پین ورودی (Pin)**: ورودی `Instruction` (دستورالعمل 32 بیتی) را دریافت می‌کند[cite: 384, 385].
* [cite_start]**پین‌های خروجی (Pins)**: خروجی‌هایی مانند `ALUselecting` (برای انتخاب عملیات ALU) [cite: 384] [cite_start]و `RegWen` (فعال‌سازی نوشتن در فایل رجیستر) [cite: 382] را تولید می‌کند.
* [cite_start]**جداکننده (Splitter)**: برای دیکد کردن بیت‌های دستورالعمل و استخراج بیت‌های مربوط به opcode و funct[cite: 383, 384, 385].
* [cite_start]**گیت‌های AND و OR**: برای پیاده‌سازی منطق ترکیبی که سیگنال‌های کنترلی را تولید می‌کند[cite: 404, 405, 406, 407].
* [cite_start]**تونل‌ها (Tunnels)**: برای سیگنال‌های داخلی مانند `A0T` تا `A3T` (برای ALU selecting) [cite: 380, 382, 383] [cite_start]و `addT`, `subT`, `orT`, `andT`, `i2T` تا `i6T` (برای بیت‌های opcode/funct)[cite: 380, 381, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401].

### ۲.۱۱. DataPath (مسیر داده - یک مدار ساده‌تر)
[cite_start]این مدار یک نمای کلی و ساده‌تر از مسیر داده را نشان می‌دهد و شامل اجزای اصلی مانند `ALU`, `Rsplitor`, `RegisterFile` و `ControlLogic` است[cite: 415, 416].
* [cite_start]**پین‌ها (Pins)**: ورودی `Constant` [cite: 416] [cite_start]و `Clock` [cite: 416] [cite_start]و خروجی `Outt`[cite: 415].
* [cite_start]**اتصالات (Wires)**: سیم‌ها نشان می‌دهند که چگونه این ماژول‌ها برای تشکیل یک مسیر داده اولیه به هم متصل شده‌اند و جریان سیگنال بین آن‌ها چگونه است[cite: 416, 417, 418].

### ۲.۱۲. ControlLogicROM (منطق کنترل بر اساس ROM)
[cite_start]این مدار از یک `ROM` برای تولید سیگنال‌های کنترلی استفاده می‌کند که یک روش رایج برای پیاده‌سازی واحد کنترل است[cite: 445].
* [cite_start]**پین‌ها (Pins)**: ورودی `Instruction` (دستورالعمل) [cite: 425] [cite_start]و خروجی‌هایی مانند `immSelect` (انتخاب نوع ثابت) [cite: 422][cite_start], `ALUselecting` (انتخاب عملیات ALU) [cite: 423][cite_start], `RegWen` (فعال‌سازی نوشتن در رجیستر) [cite: 424][cite_start], `Bselect` (انتخاب شاخه) [cite: 424][cite_start], `WEmem` (فعال‌سازی نوشتن در حافظه) [cite: 418, 419] [cite_start]و `BEQ` (سیگنال شاخه برابر) [cite: 419] را دارد.
* [cite_start]**ROM (حافظه فقط خواندنی)**: یک ROM با عرض آدرس ۹ بیت و عرض داده ۱۳ بیت، که محتوای آن سیگنال‌های کنترلی را بر اساس بیت‌های دستورالعمل تعیین می‌کند[cite: 445, 446].
* [cite_start]**جداکننده (Splitter)**: برای استخراج بیت‌های دستورالعمل که به عنوان آدرس ورودی ROM استفاده می‌شوند[cite: 422, 423, 425].
* [cite_start]**تونل‌ها (Tunnels)**: برای ارتباط داخلی و خارجی[cite: 419, 420, 421, 422, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444].

### ۲.۱۳. ALUCtl (کنترل‌کننده ALU)
[cite_start]این مدار احتمالاً برای انتخاب ورودی B به ALU استفاده می‌شود، که می‌تواند از `rs2` یا `immediate` باشد[cite: 448].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `rs2`, `imm31_0` (مقدار ثابت) [cite: 448, 449] [cite_start]و `Bselect` (انتخاب‌گر) [cite: 449] [cite_start]و خروجی `DataB` (ورودی نهایی B برای ALU) [cite: 450] را دارد.
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: بر اساس `Bselect`، یکی از ورودی‌ها (`rs2` یا `imm31_0`) را به `DataB` هدایت می‌کند[cite: 450].

### ۲.۱۴. LoadByte (بارگذاری بایت)
[cite_start]این مدار عملیات بارگذاری یک بایت را از حافظه شبیه‌سازی می‌کند، و قابلیت بارگذاری بایت علامت‌دار و بدون علامت را دارد[cite: 451].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` (آدرس) [cite: 452][cite_start]، `lw` (داده‌ی خوانده شده از حافظه) [cite: 453] [cite_start]و خروجی‌های `LoadB` (بایت علامت‌دار) [cite: 456] [cite_start]و `LoadBU` (بایت بدون علامت) [cite: 457] را دارد.
* [cite_start]**جداکننده بیت (BitSelector)**: برای استخراج بایت مورد نظر از کلمه‌ی 32 بیتی[cite: 458].
* [cite_start]**شیفت‌دهنده (Shifter)**: برای شیفت بایت به مکان صحیح در کلمه‌ی 32 بیتی[cite: 458, 459].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش بایت به 32 بیت با Sign Extend یا Zero Extend[cite: 455].

### ۲.۱۵. Loadhalf (بارگذاری نیم‌کلمه)
[cite_start]این مدار شبیه به LoadByte است، اما برای بارگذاری یک نیم‌کلمه (16 بیت) از حافظه طراحی شده است[cite: 460].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` (آدرس) [cite: 462][cite_start]، `lw` (داده‌ی خوانده شده از حافظه) [cite: 462] [cite_start]و خروجی‌های `LoadH` (نیم‌کلمه‌ی علامت‌دار) [cite: 465] [cite_start]و `LoadHU` (نیم‌کلمه‌ی بدون علامت) [cite: 466] را دارد.
* [cite_start]**جداکننده بیت (BitSelector)**: برای استخراج نیم‌کلمه‌ی مورد نظر[cite: 466].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش نیم‌کلمه به 32 بیت[cite: 463, 464].

### ۲.۱۶. LoadCrtl (کنترل بارگذاری)
[cite_start]این مدار عملیات بارگذاری نهایی را مدیریت می‌کند و داده‌ی خوانده شده از حافظه را بر اساس نوع بارگذاری (بایت، نیم‌کلمه، کلمه) و علامت‌دار/بدون علامت بودن آن، انتخاب و به خروجی می‌دهد[cite: 468].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` (آدرس) [cite: 468][cite_start], `lw` (داده‌ی خوانده شده از حافظه) [cite: 468, 469][cite_start], `lSelect` (انتخاب نوع بارگذاری) [cite: 469] [cite_start]و `wbselect` (انتخاب نهایی) [cite: 469] [cite_start]و خروجی `Data` (داده‌ی نهایی بارگذاری شده) [cite: 478] را دارد.
* [cite_start]**مالتی‌پلکسرها (Multiplexers)**: برای انتخاب بین خروجی‌های `LoadByte`, `Loadhalf` و داده‌ی کامل (word)[cite: 478].
* [cite_start]**کامپوننت‌های فرعی**: از ماژول‌های `LoadByte` [cite: 478] [cite_start]و `Loadhalf` [cite: 478] استفاده می‌کند.

### ۲.۱۷. IM (Instruction Memory - حافظه دستورالعمل)
[cite_start]این مدار یک ROM (حافظه فقط خواندنی) است که دستورالعمل‌های برنامه را ذخیره می‌کند و بر اساس آدرس ورودی، دستورالعمل مربوطه را خروجی می‌دهد[cite: 480].
* [cite_start]**پین‌ها (Pins)**: ورودی `ADDR` (آدرس دستورالعمل) [cite: 480] [cite_start]و خروجی 32 بیتی (دستورالعمل)[cite: 483, 484].
* [cite_start]**ROM (حافظه فقط خواندنی)**: یک `ROM` با عرض آدرس 16 بیت و عرض داده 32 بیت[cite: 484].

### ۲.۱۸. Zeroflag (پرچم صفر)
[cite_start]این مدار یک پرچم `Zero` را تولید می‌کند که نشان می‌دهد آیا نتیجه‌ی یک عملیات صفر است یا خیر[cite: 484, 485].
* [cite_start]**پین ورودی (Pin)**: `inputZero` (مقدار 32 بیتی ورودی برای بررسی صفر بودن)[cite: 486].
* **گیت NOR (NOR Gate)**: یک گیت NOR با ورودی‌های زیاد (32 ورودی در اینجا) می‌تواند برای تشخیص صفر بودن یک کلمه‌ی 32 بیتی استفاده شود. [cite_start]اگر همه‌ی بیت‌ها صفر باشند، خروجی NOR برابر با 1 (صفر بودن) خواهد بود[cite: 487].

---

## ۳. نتیجه‌گیری

مدارهای تعریف‌شده در فایل `fin.txt` یک شبیه‌سازی جامع و ماژولار از بخش‌های کلیدی یک مسیر داده‌ی پردازنده را در Logisim-evolution ارائه می‌دهند. از واحدهایی مانند Program Counter، فایل رجیستر، ALU و حافظه دستورالعمل گرفته تا کنترل‌کننده‌های پیچیده‌تر برای تولید مقادیر ثابت و مدیریت عملیات بارگذاری، همه به دقت مدل‌سازی شده‌اند. این طراحی ماژولار امکان تست و دیباگ هر بخش را به صورت جداگانه فراهم می‌کند و سپس آن‌ها را در یک سیستم کامل یکپارچه می‌سازد. این پروژه نه تنها به درک عمیق‌تر معماری کامپیوتر کمک می‌کند، بلکه نشان‌دهنده توانایی‌های Logisim-evolution در طراحی و شبیه‌سازی سیستم‌های دیجیتال پیچیده است.

---

Created By - Nima Ghaffari & Parsa Zandi

---

<p align="left">
  <a href="https://t.me/nimaghaffari001" style="margin-right: 10px;">
    <img src="https://img.shields.io/badge/Private%20Message-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram PV">
  </a>
  <a href="https://t.me/CallMeNiMChe">
    <img src="https://img.shields.io/badge/Telegram%20Channel-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Channel">
  </a>
</p>

---