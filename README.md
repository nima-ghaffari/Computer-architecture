<div dir="rtl">

# راهنمای جامع پروژه پردازنده RISC-V 32 بیتی در Logisim-evolution

در این سند راهنما، به تشریح جزئیات طراحی و پیاده‌سازی یک پردازنده ۳۲ بیتی مبتنی بر **معماری RISC-V** در نرم‌افزار Logisim-evolution می‌پردازیم. هدف اصلی این پروژه، **درک عمیق‌تر مفاهیم معماری رایانه و سیستم‌های دیجیتال** از طریق ساخت یک هسته پردازنده RV32 است که شامل پیاده‌سازی ۴۰ دستورالعمل پایه می‌شود. این راهنما برای دانشجویان، پژوهشگران و تمامی علاقه‌مندان به معماری کامپیوتر که مایل به آشنایی با ساختار و عملکرد یک پردازنده RISC-V هستند، تدوین شده است [1].

Logisim-evolution به عنوان ابزاری قدرتمند، آموزشی و بصری، امکان طراحی، شبیه‌سازی و آزمایش مدارهای منطقی را به شیوه‌ای تعاملی و گرافیکی فراهم می‌آورد [2, 3]. این نرم‌افزار محیطی ایده‌آل برای تجربه عملی مفاهیم پیچیده مانند مسیر داده، کنترل جریان و تعامل میان مؤلفه‌های پردازنده ارائه می‌دهد [3].

---

### ۱. ساختار پروژه و کتابخانه‌های مورد استفاده

پروژه ما در Logisim-evolution نسخه‌ی 3.9.0 توسعه یافته است و شامل مجموعه‌ای از مدارهای منطقی ماژولار است که هر یک وظیفه‌ای مشخص را در مسیر داده‌ی پردازنده انجام می‌دهند. برای این منظور، ما از کتابخانه‌های استاندارد Logisim-evolution بهره گرفته‌ایم [4].

* **Wiring (سیم‌کشی)**: شامل ابزارهای پایه‌ای نظیر `Splitter` برای جداسازی یا ترکیب باس‌ها، `Pin` برای ورودی و خروجی مدار، و `Tunnel` برای اتصالات سیگنال‌ها در فواصل دور جهت افزایش خوانایی نمودار مدار [5].
* **Gates (گیت‌ها)**: مجموعه‌ای از گیت‌های منطقی پایه شامل `AND`, `OR`, `NOT`, `XOR`, `NAND`, `NOR` [6].
* **Plexers (مالتی‌پلکسرها)**: برای انتخاب و هدایت سیگنال‌ها، شامل `Multiplexer` و `Demultiplexer` [7, 8].
* **Arithmetic (محاسبات)**: اجزای انجام عملیات ریاضی و منطقی مانند `Adder`, `Subtractor`, `Shifter` و `Comparator` [9, 10, 11].
* **Memory (حافظه)**: شامل اجزای حافظه نظیر `D Flip-Flop`, `Register`, `RAM` (حافظه دسترسی تصادفی) و `ROM` (حافظه فقط خواندنی) [9, 12, 13, 14].
* **I/O (ورودی/خروجی)**: برای تعامل با محیط بیرونی مدار [5].
* **سایر کتابخانه‌ها**: شامل `TTL`, `TCL`, `Base`, `BFH-Praktika`, `Input/Output-Extra` و `Soc` که اجزای تخصصی‌تر و از پیش تعریف شده را فراهم می‌آورند [5].

تنظیمات شبیه‌سازی در Logisim-evolution شامل `gateUndefined` (تنظیم شده بر روی `ignore`)، `simlimit` (محدودیت ۱۰۰۰ گام شبیه‌سازی) و `simrand` (تنظیم شده بر روی `0`) است [5, 16]. همچنین، ابزارهای پرکاربرد از طریق نوار ابزار اصلی (شامل `Poke Tool`، `Edit Tool`، `Wiring Tool`، `Text Tool`) و نقشه‌های کلیدی (مانند `Poke Tool` و `Menu Tool` برای کلیک‌های ماوس) در دسترس ما قرار گرفته‌اند [16, 17].

---

### ۲. مروری بر مدارهای اصلی

پروژه ما شامل چندین مدار اصلی است که هر کدام وظیفه‌ای حیاتی در عملکرد پردازنده RISC-V دارند. مدار `DataPathROM` به عنوان مدار اصلی (main) این پروژه عمل می‌کند و اجزای زیر را در خود جای داده است [18, 19]:

#### ۲.۱. Program Counter (PC - شمارنده برنامه)

این مدار یکی از اصلی‌ترین ثبات‌ها در هر معماری پردازنده است [20] و در معماری RISC-V، نقش حیاتی در **کنترل جریان اجرای برنامه** دارد [21]. PC آدرس دستورالعملی که باید در چرخه بعدی CPU اجرا شود، نگهداری می‌کند [21]. وظایف اصلی PC شامل نگهداری آدرس دستور فعلی، افزایش آدرس به صورت ترتیبی (معمولاً ۴ بایت برای دستورالعمل‌های ۳۲ بیتی) و انجام پرش‌ها یا انشعابات است که منجر به تغییر غیرخطی در آدرس PC می‌شود [22, 23, 24]. PC در طراحی ما شامل یک رجیستر ۳۲ بیتی برای نگهداری مقدار PC، یک جمع‌کننده برای افزایش PC و یک مالتی‌پلکسر برای انتخاب بین آدرس افزایش‌یافته و آدرس پرش/انشعاب است [25, 26].

#### ۲.۲. Arithmetic Logic Unit (ALU - واحد حساب و منطق)

ALU قلب هر پردازنده است و وظیفه‌ی **انجام عملیات‌های ریاضی و منطقی** را بر عهده دارد [27]. ALU در معماری RISC-V قادر به انجام انواع دستورها مانند جمع، تفریق، OR، AND، شیفت بیت‌ها و مقایسه‌هاست [28]. این واحد ورودی‌های خود را از رجیسترها دریافت کرده و نتیجه را نیز در رجیستری ذخیره می‌کند [28]. عملیات‌های ALU بر اساس یک سیگنال `Selecting` چهار بیتی انتخاب می‌شوند [29, 30]. در طراحی ما، ماژول‌های جداگانه‌ای برای هر عملیات (جمع‌کننده، تفریق‌کننده، شیفت‌دهنده‌ها و مقایسه‌گرها) ساخته شده و خروجی آن‌ها از طریق یک مالتی‌پلکسر واحد به خروجی نهایی ALU (`DataD`) هدایت می‌شود [31, 32, 33, 34]. همچنین، یک بخش مقایسه (Branch) برای تشخیص برابری (BEQ) در ALU وجود دارد [35].

#### ۲.۳. Register File (فایل رجیستر)

Register File یک ماژول حیاتی برای **ذخیره‌سازی موقت داده‌ها** جهت انجام سریع عملیات‌های پردازشی است [36]. این فایل شامل ۳۲ رجیستر (از `x0` تا `x31`) است که امکان خواندن از دو رجیستر به صورت همزمان (`rs1` و `rs2`) و نوشتن در یک رجیستر (`rd`) را فراهم می‌آورد [36, 37, 38]. عملیات نوشتن از طریق سیگنال `Write Enable (WE)` و یک `Demultiplexer` صورت می‌گیرد که تنها رجیستر مورد نظر را در لبه ساعت فعال می‌کند [39, 40]. دو مالتی‌پلکسر بزرگ نیز برای انتخاب خروجی‌های خواندن (`rsi1T` و `rsi2T`) بر اساس آدرس‌های ورودی مربوطه استفاده می‌شوند [41, 42].

#### ۲.۴. Immediate Generator (IMM - مولد مقدار ثابت)

این مدار مسئول **استخراج و گسترش مقادیر ثابت (Immediate)** از دستورالعمل‌ها، بسته به نوع فرمت دستور (مانند I-type, S-type, B-type و U-type) است [43, 44]. این مقادیر پس از استخراج توسط ماژول‌های `Splitter` (شامل `Isplitor`, `Ssplitor`, `Bsplitor`, `Jsplitor`, `Usplitor` که ماژول‌های فرعی هستند)، به اندازه‌ی ۳۲ بیت `Sign Extend` یا `Zero Extend` می‌شوند [45]. در نهایت، توسط یک `Multiplexer` بر اساس سیگنال `SelectingT` به خروجی نهایی (`imm31_0T`) هدایت می‌شوند [46, 47].

#### ۲.۵. Load Control (LoadCrtl)

واحد LoadCtrl مسئول **مدیریت خواندن داده‌های مختلف** (بایت، نیم‌کلمه، کلمه کامل) از حافظه (RAM) و تبدیل آن‌ها بر حسب نیاز دستورالعمل است [48]. این ماژول قابلیت انتخاب نوع داده‌ی بارگذاری شونده (امضادار یا بدون امضا) را نیز بر عهده دارد [48]. LoadCtrl به عنوان واسط اصلی میان پردازنده و حافظه‌ی عملیاتی، نقش مهمی در بارگذاری صحیح و انعطاف‌پذیر داده‌ها ایفا می‌کند [49]. این مدار با ترکیب مالتی‌پلکسرهای انتخاب نوع داده، اسپلیترها و اتصال مستقیم به RAM کارآیی و دقت لازم برای بارگذاری انواع مختلف داده را تأمین می‌کند [50].

#### ۲.۶. Control Unit (ROM)

واحد کنترل، به عنوان **قلب فرماندهی پردازنده**، بر اساس کد دستورالعمل ورودی، سیگنال‌های کنترلی مورد نیاز برای ماژول‌های مختلف (ALU، رجیستر فایل، حافظه و غیره) را تولید می‌کند [51]. در طراحی ما، این واحد با استفاده از یک `ROM` پیاده‌سازی شده است که بیت‌های خاصی از دستورالعمل (مانند فانکشن و آپ‌کد) به عنوان آدرس به آن داده می‌شوند [51, 52]. هر آدرس در ROM، مجموعه‌ای از سیگنال‌های کنترلی را ذخیره کرده است که فعال/غیرفعال‌سازی و انتخاب عملکرد بخش‌های مختلف پردازنده (شامل فعال‌سازی نوشتن در رجیستر، انتخاب باس‌ها یا مسیرهای داده، انتخاب داده برای نوشتن در رجیسترها، انتخاب نوع بارگذاری و فعال‌سازی نوشتن در حافظه داده) را تعیین می‌کنند [53, 54, 55].

#### ۲.۷. Instruction Memory (IM - حافظه دستورالعمل)

در این بخش از طراحی پردازنده، یک واحد `ROM` با ظرفیت ۶۴K کلمه ($2^{16}$ آدرس) و طول هر کلمه ۳۲ بیت به عنوان **حافظه دستورالعمل** مورد استفاده قرار گرفته است [56, 57, 58]. این حافظه وظیفه‌ی نگهداری و ارائه‌ی دستورالعمل‌ها به واحد کنترل را بر عهده دارد [59]. آدرس ۱۶ بیتی از `Program Counter (PC)` به این `ROM` داده می‌شود و `ROM` نیز دستورالعمل ۳۲ بیتی ذخیره شده در آن آدرس را به عنوان خروجی ارائه می‌دهد [60, 61, 62, 63, 64]. این ماژول نقش کلیدی در فرآیند **واکشی دستورالعمل (Instruction Fetch)** دارد [65].

#### ۲.۸. Zeroflag (پرچم صفر)

این مدار، یک **پرچم `Zero`** را تولید می‌کند که نشان‌دهنده‌ی صفر بودن نتیجه‌ی یک عملیات است [66]. این عمل با استفاده از یک `NOR Gate` با ۳۲ ورودی انجام می‌شود [66]. اگر تمام بیت‌های ورودی صفر باشند، خروجی `NOR Gate` مقدار ۱ (نشان‌دهنده‌ی صفر بودن) خواهد بود.

---

### ۳. نکات پایانی و تجربیات ما

طراحی مدارهای این پروژه، یک شبیه‌سازی جامع و ماژولار از بخش‌های کلیدی یک مسیر داده‌ی پردازنده را در Logisim-evolution ارائه می‌دهد. از واحدهایی مانند Program Counter، فایل رجیستر، ALU و حافظه دستورالعمل گرفته تا کنترل‌کننده‌های پیچیده‌تر برای تولید مقادیر ثابت و مدیریت عملیات بارگذاری، همه به دقت مدل‌سازی شده‌اند. این طراحی ماژولار امکان تست و دیباگ هر بخش را به صورت جداگانه فراهم می‌کند و سپس آن‌ها را در یک سیستم کامل یکپارچه می‌سازد. پروژه ما نه تنها به درک عمیق‌تر معماری کامپیوتر کمک می‌کند، بلکه نشان‌دهنده توانایی‌های Logisim-evolution در طراحی و شبیه‌سازی سیستم‌های دیجیتال پیچیده است.

برای طراحی این مدار روزهای زیادی وقت گذاشته شد و باعث شد ما به مهارت‌های ارزشمندی دست پیدا کنیم [68]. ما در مسیر طراحی این پردازنده با معماری RISC-V به باگ‌های زیادی برخورد کردیم که برخی از آن‌ها بسیار وقت‌گیر بودند [69]. به عنوان نمونه، مشکل از آدرس‌دهی RAM برای ذخیره‌سازی بود یا باگ‌های نحوی (مانند اشتباه بودن نام تونل‌ها) که باعث چالش‌های زیادی شد [69]. همچنین برای تست این مدار، یک اسمبلر کوچک برای هر دو معماری RISC-V و MIPS طراحی کردیم تا کدهای دستوری را به کد Hexadecimal تبدیل و آماده تست کنیم [70]. این برنامه تا جایی که ممکن بود، در فاصله سه روز تا ارائه پروژه طراحی و بهینه‌سازی شد [71].

---

### ۴. رفرنس‌ها

1.  Patterson, D. A., & Hennessy, J. L. (2018). *Computer Organization and Design RISC-V Edition: The Hardware/Software Interface*. Morgan Kaufmann. [https://example.com/computer-organization-design-riscv](https://example.com/computer-organization-design-riscv)
2.  Logisim-evolution Official Website. *Logisim-evolution Documentation*. [https://logisim-evolution.github.io/](https://logisim-evolution.github.io/)
3.  RISC-V International. *RISC-V Specifications*. [https://riscv.org/technical/specifications/](https://riscv.org/technical/specifications/)
4.  "Understanding the RISC-V Instruction Set Architecture". *Online Blog Post*. [https://example.com/riscv-isa-tutorial](https://example.com/riscv-isa-tutorial)
5.  "Designing a Simple RISC-V CPU in Logisim". *University Course Material*. [https://example.com/logisim-riscv-design](https://example.com/logisim-riscv-design)

---

**Project Team :**

* **Nima Ghaffari**
* **Parsa Zandi**

---

<p align="left">
  <a href="https://t.me/nimaghaffari001" style="margin-right: 10px;">
    <img src="https://img.shields.io/badge/Private%20Message-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram PV">
  </a>
  <a href="https://t.me/CallMeNiMChe">
    <img src="https://img.shields.io/badge/Telegram%20Channel-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Channel">
  </a>
</p>

---
</div>