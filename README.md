# راهنمای جامع مدارهای Logisim-evolution (بر اساس فایل پروژه)

این سند به تشریح کامل مدارهای طراحی شده در نرم‌افزار Logisim-evolution، که از فایل پروژه استخراج شده‌اند، می‌پردازد. این مدارها هسته‌ی یک مسیر داده (Datapath) پردازنده را تشکیل می‌دهند و به منظور شبیه‌سازی عملکرد بخش‌های مختلف یک CPU طراحی شده‌اند. [cite_start]این پروژه توسط Logisim-evolution نسخه‌ی 3.9.0 توسعه یافته است، که نسخه‌ی پیشرفته‌تر و متن‌باز Logisim اصلی است و قابلیت‌های بیشتری برای طراحی و تحلیل مدارهای منطقی دیجیتال ارائه می‌دهد[cite: 1].

---

## ۱. ساختار فایل پروژه و کتابخانه‌ها

[cite_start]فایل پروژه Logisim-evolution علاوه بر تعاریف مدارها، شامل تنظیمات کلی محیط شبیه‌سازی و کتابخانه‌های مورد استفاده نیز می‌باشد[cite: 1].

### ۱.۱. کتابخانه‌های مورد استفاده
[cite_start]در این پروژه، از کتابخانه‌های استاندارد Logisim-evolution استفاده شده است که هر کدام مجموعه‌ای از اجزای پرکاربرد برای ساخت مدارهای دیجیتال را در خود جای داده‌اند[cite: 2]:
* [cite_start]**#Wiring (سیم‌کشی)**: شامل ابزارهای اساسی برای اتصال و مسیریابی سیگنال‌ها مانند `Splitter` (جداکننده بیت‌ها از یک باس یا ترکیب آن‌ها)، `Pin` (پین‌های ورودی و خروجی مدار) و `Tunnel` (برای نامگذاری و اتصال سیگنال‌ها در فواصل دور برای افزایش خوانایی)[cite: 2].
* [cite_start]**#Gates (گیت‌ها)**: حاوی گیت‌های منطقی پایه مانند `AND`, `OR`, `NOT`, `XOR`, `NAND`, `NOR`[cite: 2].
* [cite_start]**#Plexers (مالتی‌پلکسرها)**: شامل `Multiplexer` (انتخاب یکی از چند ورودی) و `Demultiplexer` (هدایت یک ورودی به یکی از چند خروجی)[cite: 2].
* [cite_start]**#Arithmetic (محاسبات)**: اجزای مربوط به عملیات محاسباتی و منطقی نظیر `Adder` (جمع‌کننده), `Subtractor` (تفریق‌کننده), `Shifter` (شیفت‌دهنده) و `Comparator` (مقایسه‌کننده)[cite: 2].
* [cite_start]**#Memory (حافظه)**: اجزای حافظه مانند `D Flip-Flop` (فلیپ‌فلاپ D), `Register` (رجیستر), `RAM` (حافظه دسترسی تصادفی) و `ROM` (حافظه فقط خواندنی)[cite: 2].
* [cite_start]**#I/O (ورودی/خروجی)**: شامل اجزای ورودی/خروجی[cite: 2].
* [cite_start]**سایر کتابخانه‌ها**: شامل `TTL`, `TCL`, `Base`, `BFH-Praktika`, `Input/Output-Extra` و `Soc` که می‌توانند اجزای تخصصی‌تر و از پیش تعریف شده را ارائه دهند[cite: 2].

### ۱.۲. تنظیمات و نوار ابزار
* **تنظیمات شبیه‌سازی**:
    * [cite_start]`gateUndefined` روی `ignore` تنظیم شده است، به این معنی که حالت‌های تعریف‌نشده گیت‌ها در شبیه‌سازی نادیده گرفته می‌شوند[cite: 2].
    * [cite_start]`simlimit` روی `1000` تنظیم شده است که احتمالا حداکثر تعداد گام‌های شبیه‌سازی را تعیین می‌کند[cite: 2].
    * [cite_start]`simrand` روی `0` تنظیم شده است که به شبیه‌سازی تصادفی مربوط می‌شود[cite: 3].
* **نقشه‌های کلیدی (Key Mappings)**: ابزارهای مختلف Logisim به دکمه‌های ماوس نگاشت شده‌اند. [cite_start]به عنوان مثال، `Button2` (کلیک وسط) به `Poke Tool` و `Button3` (کلیک راست) به `Menu Tool` اختصاص داده شده است[cite: 3].
* [cite_start]**نوار ابزار (Toolbar)**: نوار ابزار دسترسی سریع به ابزارهای پرکاربرد مانند `Poke Tool`، `Edit Tool`، `Wiring Tool`، `Text Tool`، پین‌های ورودی/خروجی، گیت‌های منطقی، و رجیسترها را فراهم می‌کند[cite: 3, 4].

---

## ۲. مدارهای اصلی (Circuits) تعریف شده

فایل پروژه شامل چندین مدار (Circuit) است که هر کدام وظیفه‌ای خاص را در یک پردازنده شبیه‌سازی می‌کنند. [cite_start]مدار `DataPathROM` به عنوان مدار اصلی (main) پروژه تعیین شده است[cite: 2, 4].

### ۲.۱. DataPathROM (مسیر داده با حافظه فقط خواندنی)
[cite_start]این مدار اصلی‌ترین بخش پروژه است و اجزای مختلف یک مسیر داده‌ی پردازنده را به هم متصل می‌کند[cite: 4].
* **تونل‌ها (Tunnels)**: برای انتقال سیگنال‌ها با نام‌های مشخص مانند `RS1T`, `immselect`, `ALUop`, `ZeroFlagg`, `CLKT`, `OutPutT`, `rs1`, `rs2`, `rdi`. [cite_start]این تونل‌ها به شدت خوانایی نمودار مدار را افزایش می‌دهند، زیرا نیازی به رسم سیم‌های طولانی در سراسر مدار نیست[cite: 5, 6, 8, 9, 10, 11, 15, 16, 28, 30, 34, 43].
* [cite_start]**پین (Pin)**: برای ورودی و خروجی نهایی مدار، مثل `Result` که خروجی نهایی 32 بیتی را نمایش می‌دهد[cite: 9].
* [cite_start]**کلاک (Clock)**: برای تولید پالس ساعت جهت همگام‌سازی اجزای ترتیبی مدار (مثال: در مختصات (350,320))[cite: 8].
* [cite_start]**جداکننده (Splitter)**: برای تقسیم یک سیگنال چند بیتی به سیگنال‌های کوچکتر (مانند استخراج بیت‌های خاص از یک دستورالعمل 32 بیتی) یا ترکیب چند سیگنال کوچکتر به یک باس بزرگتر[cite: 11, 12, 13, 14].
* [cite_start]**ثابت (Constant)**: برای تولید مقادیر ثابت هگزادسیمال (مثال: `0x2` یا `0x0`)[cite: 7, 15].
* [cite_start]**درگاه AND (AND Gate)**: برای انجام عملیات منطقی AND[cite: 17].
* [cite_start]**انتخاب‌گر بیت (BitSelector)**: برای انتخاب گروهی از بیت‌ها از یک ورودی چند بیتی[cite: 17].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب یکی از چندین ورودی بر اساس یک سیگنال انتخاب‌گر[cite: 17].
* [cite_start]**شیفت‌دهنده (Shifter)**: برای انجام عملیات شیفت منطقی یا حسابی (مثال: `lr` برای شیفت منطقی به راست)[cite: 17, 18].
* [cite_start]**RAM (حافظه دسترسی تصادفی)**: یک ماژول حافظه قابل خواندن و نوشتن با عرض داده 32 بیت[cite: 18].
* [cite_start]**کامپوننت‌های فرعی (Sub-Circuits)**: این مدار به چندین مدار فرعی دیگر متصل است که هر یک وظیفه‌ی خاصی را بر عهده دارند: `RegisterFile` (فایل رجیستر), `ControlLogicROM` (منطق کنترل ROM), `ALU` (واحد حساب و منطق), `Zeroflag` (پرچم صفر), `LoadCrtl` (کنترل بارگذاری), `IMM` (مولد مقادیر ثابت) و `PC` (شمارنده برنامه)[cite: 18, 19].

### ۲.۲. PC (Program Counter - شمارنده برنامه)
[cite_start]این مدار مسئول نگهداری آدرس دستورالعمل فعلی و تولید آدرس دستورالعمل بعدی است[cite: 590, 593, 595].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `Clk` (کلاک)، `Boffset` (آفست شاخه) و `PCsrc` (کنترل‌کننده انتخاب منبع PC) و خروجی `outInstruction` (دستورالعمل خروجی) را دارد[cite: 26, 27, 29].
* [cite_start]**رجیستر (Register)**: یک رجیستر 32 بیتی برای نگهداری مقدار PC[cite: 30, 31].
* [cite_start]**جمع‌کننده (Adder)**: برای افزایش مقدار PC به اندازه‌ی 4 (برای دستورالعمل‌های متوالی) یا اضافه کردن آفست شاخه[cite: 30].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب مقدار بعدی PC، که می‌تواند حاصل افزایش PC یا آدرس هدف یک شاخه باشد[cite: 29].
* [cite_start]**IM (حافظه دستورالعمل)**: این بخش به یک ماژول حافظه دستورالعمل (`IM`) متصل است که دستورالعمل‌ها را از آدرس PC خوانده و خروجی می‌دهد[cite: 31].

### ۲.۳. RegisterFile (فایل رجیستر)
[cite_start]این مدار 32 رجیستر 32 بیتی (مانند `x0` تا `x31` در RISC-V) را شبیه‌سازی می‌کند و امکان خواندن از دو رجیستر و نوشتن در یک رجیستر را فراهم می‌آورد[cite: 716, 717].
* **پین‌ها (Pins)**: ورودی‌هایی برای آدرس‌های خواندن (`rsi1`, `rsi2`)، آدرس نوشتن (`rdi`)، داده‌ی ورودی برای نوشتن (`rd`)، سیگنال فعال‌سازی نوشتن (`we`) و کلاک (`Clk`) دارد. [cite_start]همچنین دو خروجی 32 بیتی برای داده‌های خوانده شده (`rs1`, `rs2`) ارائه می‌دهد[cite: 32, 33, 34, 37, 44, 45, 743, 744, 746, 749, 750, 751, 754].
* [cite_start]**رجیسترها (Registers)**: هر رجیستر به عنوان یک جزء `Register` با لیبل‌های `x0` تا `x31` تعریف شده است[cite: 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139].
* [cite_start]**دیمالتی‌پلکسر (Demultiplexer)**: برای هدایت سیگنال `WE` (Write Enable) به رجیستر صحیح بر اساس آدرس نوشتن (`rdi`)[cite: 127, 758, 762].
* [cite_start]**مالتی‌پلکسرها (Multiplexers)**: دو مالتی‌پلکسر برای انتخاب داده خروجی از رجیسترها بر اساس آدرس‌های خواندن (`rsi1` و `rsi2`)[cite: 127, 128, 759, 766].
* [cite_start]**تونل‌ها (Tunnels)**: برای ارتباط داخلی بین پین‌ها و رجیسترهای تکی[cite: 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127].

### ۲.۴. ALU (Arithmetic Logic Unit - واحد حساب و منطق)
[cite_start]این مدار یک واحد حساب و منطق 32 بیتی را پیاده‌سازی می‌کند که قادر به انجام عملیات مختلف محاسباتی و منطقی است[cite: 628, 629].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `DataA`, `DataB` (عملوندها) و `Selecting` (سیگنال انتخاب عملیات) و خروجی `DataD` (نتیجه عملیات) را دارد[cite: 158, 159, 180, 181, 688, 689, 690, 691].
* [cite_start]**عملگرها**: شامل `Subtractor` (تفریق), `Adder` (جمع), `Shifter` (شیفت به چپ/راست منطقی و حسابی), `Comparator` (مقایسه برای `slt` و `sltu`), `OR Gate`, `AND Gate`, `XOR Gate` (عملیات منطقی)[cite: 182, 183, 693, 694, 695, 701].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش سیگنال‌های تک بیتی (مثلاً نتیجه مقایسه) به 32 بیت، معمولاً با صفر یا با Sign (مقدار علامت)[cite: 172, 173, 178, 179].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب خروجی نهایی ALU بر اساس سیگنال `Selecting`[cite: 181, 182, 706, 707].
* [cite_start]**متن (Text)**: توضیحات مربوط به کدهای انتخاب برای عملیات ALU را نشان می‌دهد (مثال: add 0000, sub 1000, sll 0001 و ...)[cite: 183, 184, 630].
* [cite_start]**Branch (شاخه)**: به یک مدار `Branch` برای بررسی شرایط شاخه متصل است[cite: 184].

### ۲.۵. Branch (مدار شاخه)
[cite_start]این مدار برای مقایسه دو مقدار و تولید سیگنال `brEq` (برابر بودن شاخه) استفاده می‌شود[cite: 704, 187].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `DataA`, `DataB` و خروجی `brEq` را دارد[cite: 188, 191].
* [cite_start]**مقایسه‌کننده (Comparator)**: برای مقایسه `DataA` و `DataB`[cite: 191].

### ۲.۶. IMM (Immediate Generator - مولد مقدار ثابت)
[cite_start]این مدار برای تولید مقادیر ثابت (immediate values) از دستورالعمل‌ها، با توجه به فرمت‌های مختلف دستورالعمل‌ها، استفاده می‌شود[cite: 771, 773].
* [cite_start]**پین‌ها (Pins)**: ورودی `selecting` (برای انتخاب نوع ثابت) و `Ins` (دستورالعمل 32 بیتی) و خروجی `imm31_0` (مقدار ثابت 32 بیتی) را دارد[cite: 194, 195, 196, 777, 778, 788].
* [cite_start]**جداکننده (Splitter)**: برای استخراج بیت‌های مختلف ثابت از دستورالعمل بر اساس فرمت آن (مانند `Ssplitor`, `Bsplitor`, `Jsplitor`, `Usplitor`, `Isplitor` که ماژول‌های فرعی هستند)[cite: 199, 200, 201, 202, 203, 204, 205, 206, 207, 780, 781].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش مقادیر ثابت به 32 بیت با Sign Extend یا Zero Extend[cite: 198, 782, 783, 784, 785].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: برای انتخاب مقدار ثابت نهایی بر اساس سیگنال `selecting`[cite: 209, 787].

### ۲.۷. مدارهای Splitter (Rsplitor, Isplitor, Ssplitor, Usplitor, Bsplitor, Jsplitor)
این مدارها، که به عنوان زیرمدار در `IMM` استفاده می‌شوند، وظیفه‌ی **دیکد کردن دستورالعمل‌ها** را بر عهده دارند. [cite_start]هر یک از آن‌ها برای استخراج بیت‌ها بر اساس فرمت خاصی از دستورالعمل (R-type, I-type, S-type, U-type, B-type, J-type) طراحی شده‌اند[cite: 780, 781].
* [cite_start]**پین ورودی (Pin)**: همگی یک پین ورودی به نام `Instruction` (یا `Instroction` یا `Ins`) با عرض 32 بیت دارند[cite: 213, 220, 226, 233, 234, 239, 247].
* [cite_start]**جداکننده (Splitter)**: هسته‌ی این مدارها یک `Splitter` است که سیگنال 32 بیتی دستورالعمل را بر اساس فرمت خاص آن به گروه‌های بیتی معنی‌دار (مانند opcode, rd, funct3, rs1, rs2, funct7 و بیت‌های مختلف immediate) تقسیم می‌کند و آن‌ها را از طریق پین‌های خروجی مربوطه ارائه می‌دهد[cite: 213, 214, 215, 216, 220, 221, 222, 223, 227, 228, 229, 230, 234, 235, 236, 237, 239, 240, 241, 242, 247, 248, 249, 250].

### ۲.۸. FullAdder (جمع‌کننده کامل)
[cite_start]با توجه به تعاریف پین‌ها و گیت‌های `XOR` و `AND` زیاد، این مدار یک **جمع‌کننده کامل 32 بیتی** یا بیشتر را پیاده‌سازی می‌کند[cite: 199, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A`, `B` (بیت‌های عملوندها) و خروجی‌های `Sum` (جمع) و `Carry Out` (حمل) را خواهد داشت[cite: 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274].
* [cite_start]**گیت‌های XOR و AND**: برای پیاده‌سازی منطق جمع و حمل در هر بیت استفاده می‌شوند[cite: 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319].
* [cite_start]**جداکننده (Splitter)**: برای تقسیم ورودی‌های چند بیتی (مانند `DataA` و `DataB`) به بیت‌های تکی[cite: 271, 272, 286, 287].

### ۲.۹. Test (مدار تست)
[cite_start]این یک مدار تست کوچک به نظر می‌رسد که از یک گیت `AND` با ۷ ورودی و چند گیت `NOT` استفاده می‌کند تا یک سیگنال `beq` (برابر بودن شاخه) را تولید کند[cite: 379, 795, 796].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `i0T` تا `i6T` و `i1T` تا `i5T` و خروجی `beq`[cite: 376, 377, 378, 379].
* [cite_start]**گیت NOR (NOR Gate)**: یک گیت `AND` با ورودی‌های negate شده[cite: 379].

### ۲.۱۰. ControlLogic (منطق کنترل)
[cite_start]این مدار سیگنال‌های کنترلی را برای `ALU` و سایر بخش‌های مسیر داده بر اساس opcode و funct3/funct7 دستورالعمل تولید می‌کند[cite: 922].
* [cite_start]**پین ورودی (Pin)**: ورودی `Instruction` (دستورالعمل 32 بیتی) را دریافت می‌کند[cite: 384, 385].
* [cite_start]**پین‌های خروجی (Pins)**: خروجی‌هایی مانند `ALUselecting` (برای انتخاب عملیات ALU) و `RegWen` (فعال‌سازی نوشتن در فایل رجیستر) را تولید می‌کند[cite: 381, 382, 383, 384].
* [cite_start]**جداکننده (Splitter)**: برای دیکد کردن بیت‌های دستورالعمل و استخراج بیت‌های مربوط به opcode و funct[cite: 383, 384, 385].
* [cite_start]**گیت‌های AND و OR**: برای پیاده‌سازی منطق ترکیبی که سیگنال‌های کنترلی را تولید می‌کند[cite: 404, 405, 406, 407].
* [cite_start]**تونل‌ها (Tunnels)**: برای سیگنال‌های داخلی مانند `A0T` تا `A3T` (برای ALU selecting) و `addT`, `subT`, `orT`, `andT`, `i2T` تا `i6T` (برای بیت‌های opcode/funct)[cite: 380, 381, 382, 383, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 944, 945, 946, 947].

### ۲.۱۱. DataPath (مسیر داده - یک مدار ساده‌تر)
[cite_start]این مدار یک نمای کلی و ساده‌تر از مسیر داده را نشان می‌دهد و شامل اجزای اصلی مانند `ALU`, `Rsplitor`, `RegisterFile` و `ControlLogic` است[cite: 987, 988, 989].
* [cite_start]**پین‌ها (Pins)**: ورودی `Constant` و `Clock` و خروجی `Outt`[cite: 415, 416].
* [cite_start]**اتصالات (Wires)**: سیم‌ها نشان می‌دهند که چگونه این ماژول‌ها برای تشکیل یک مسیر داده اولیه به هم متصل شده‌اند و جریان سیگنال بین آن‌ها چگونه است[cite: 416, 417, 418].

### ۲.۱۲. ControlLogicROM (منطق کنترل بر اساس ROM)
[cite_start]این مدار از یک `ROM` برای تولید سیگنال‌های کنترلی استفاده می‌کند که یک روش رایج برای پیاده‌سازی واحد کنترل است[cite: 922].
* [cite_start]**پین‌ها (Pins)**: ورودی `Instruction` (دستورالعمل) و خروجی‌هایی مانند `immSelect` (انتخاب نوع ثابت), `ALUselecting` (انتخاب عملیات ALU), `RegWen` (فعال‌سازی نوشتن در رجیستر), `Bselect` (انتخاب شاخه), `WEmem` (فعال‌سازی نوشتن در حافظه) و `BEQ` (سیگنال شاخه برابر) را دارد[cite: 418, 419, 420, 421, 422, 423, 424, 425, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961].
* [cite_start]**ROM (حافظه فقط خواندنی)**: یک ROM با عرض آدرس ۹ بیت و عرض داده ۱۳ بیت، که محتوای آن سیگنال‌های کنترلی را بر اساس بیت‌های دستورالعمل تعیین می‌کند[cite: 445, 965, 966].
* [cite_start]**جداکننده (Splitter)**: برای استخراج بیت‌های دستورالعمل که به عنوان آدرس ورودی ROM استفاده می‌شوند[cite: 422, 423, 432, 433, 434, 435].
* [cite_start]**تونل‌ها (Tunnels)**: برای ارتباط داخلی و خارجی[cite: 419, 420, 421, 422, 424, 425, 426, 427, 428, 429, 430, 431, 432, 436, 437, 438, 439, 440, 441, 442, 443, 444].

### ۲.۱۳. ALUCtl (کنترل‌کننده ALU)
[cite_start]این مدار برای انتخاب ورودی B به ALU استفاده می‌شود، که می‌تواند از `rs2` یا `immediate` باشد[cite: 448].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `rs2`, `imm31_0` (مقدار ثابت) و `Bselect` (انتخاب‌گر) و خروجی `DataB` (ورودی نهایی B برای ALU) را دارد[cite: 448, 449, 450].
* [cite_start]**مالتی‌پلکسر (Multiplexer)**: بر اساس `Bselect`، یکی از ورودی‌ها (`rs2` یا `imm31_0`) را به `DataB` هدایت می‌کند[cite: 450].

### ۲.۱۴. LoadByte (بارگذاری بایت)
[cite_start]این مدار عملیات بارگذاری یک بایت را از حافظه شبیه‌سازی می‌کند، و قابلیت بارگذاری بایت علامت‌دار و بدون علامت را دارد[cite: 451, 831, 832].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` (آدرس)، `lw` (داده‌ی خوانده شده از حافظه) و خروجی‌های `LoadB` (بایت علامت‌دار) و `LoadBU` (بایت بدون علامت) را دارد[cite: 452, 453, 456, 457, 838, 839].
* [cite_start]**جداکننده بیت (BitSelector)**: برای استخراج بایت مورد نظر از کلمه‌ی 32 بیتی[cite: 457, 458].
* [cite_start]**شیفت‌دهنده (Shifter)**: برای شیفت بایت به مکان صحیح در کلمه‌ی 32 بیتی[cite: 458, 459].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش بایت به 32 بیت با Sign Extend یا Zero Extend[cite: 455, 456].

### ۲.۱۵. Loadhalf (بارگذاری نیم‌کلمه)
[cite_start]این مدار شبیه به LoadByte است، اما برای بارگذاری یک نیم‌کلمه (16 بیت) از حافظه طراحی شده است[cite: 460].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` (آدرس)، `lw` (داده‌ی خوانده شده از حافظه) و خروجی‌های `LoadH` (نیم‌کلمه‌ی علامت‌دار) و `LoadHU` (نیم‌کلمه‌ی بدون علامت) را دارد[cite: 461, 462, 465, 466].
* [cite_start]**جداکننده بیت (BitSelector)**: برای استخراج نیم‌کلمه‌ی مورد نظر[cite: 466].
* [cite_start]**گسترش‌دهنده بیت (Bit Extender)**: برای گسترش نیم‌کلمه به 32 بیت[cite: 463, 464].

### ۲.۱۶. LoadCrtl (کنترل بارگذاری)
[cite_start]این مدار عملیات بارگذاری نهایی را مدیریت می‌کند و داده‌ی خوانده شده از حافظه را بر اساس نوع بارگذاری (بایت، نیم‌کلمه، کلمه) و علامت‌دار/بدون علامت بودن آن، انتخاب و به خروجی می‌دهد[cite: 1048, 831, 832, 833].
* [cite_start]**پین‌ها (Pins)**: ورودی‌های `A` (آدرس), `lw` (داده‌ی خوانده شده از حافظه), `lSelect` (انتخاب نوع بارگذاری) و `wbselect` (انتخاب نهایی) و خروجی `Data` (داده‌ی نهایی بارگذاری شده) را دارد[cite: 468, 469, 470, 477, 478, 885, 886, 887, 888, 889, 892, 893].
* [cite_start]**مالتی‌پلکسرها (Multiplexers)**: برای انتخاب بین خروجی‌های `LoadByte`, `Loadhalf` و داده‌ی کامل (word)[cite: 478, 903, 904, 905, 906].
* [cite_start]**کامپوننت‌های فرعی**: از ماژول‌های `LoadByte` و `Loadhalf` استفاده می‌کند[cite: 478].

### ۲.۱۷. IM (Instruction Memory - حافظه دستورالعمل)
[cite_start]این مدار یک ROM (حافظه فقط خواندنی) است که دستورالعمل‌های برنامه را ذخیره می‌کند و بر اساس آدرس ورودی، دستورالعمل مربوطه را خروجی می‌دهد[cite: 1090, 1095, 1096].
* [cite_start]**پین‌ها (Pins)**: ورودی `ADDR` (آدرس دستورالعمل) و خروجی 32 بیتی (دستورالعمل)[cite: 480, 483, 1102, 1142, 1143, 1151].
* [cite_start]**ROM (حافظه فقط خواندنی)**: یک `ROM` با عرض آدرس 16 بیت و عرض داده 32 بیت[cite: 484, 1097, 1098, 1099, 1100, 1103, 1150].

### ۲.۱۸. Zeroflag (پرچم صفر)
[cite_start]این مدار یک پرچم `Zero` را تولید می‌کند که نشان می‌دهد آیا نتیجه‌ی یک عملیات صفر است یا خیر[cite: 484].
* [cite_start]**پین ورودی (Pin)**: `inputZero` (مقدار 32 بیتی ورودی برای بررسی صفر بودن)[cite: 486].
* **گیت NOR (NOR Gate)**: یک گیت NOR با ورودی‌های زیاد (32 ورودی در اینجا) می‌تواند برای تشخیص صفر بودن یک کلمه‌ی 32 بیتی استفاده شود. [cite_start]اگر همه‌ی بیت‌ها صفر باشند، خروجی NOR برابر با 1 (صفر بودن) خواهد بود[cite: 487].

---

## ۳. نتیجه‌گیری

مدارهای تعریف‌شده در فایل پروژه یک شبیه‌سازی جامع و ماژولار از بخش‌های کلیدی یک مسیر داده‌ی پردازنده را در Logisim-evolution ارائه می‌دهند. از واحدهایی مانند Program Counter، فایل رجیستر، ALU و حافظه دستورالعمل گرفته تا کنترل‌کننده‌های پیچیده‌تر برای تولید مقادیر ثابت و مدیریت عملیات بارگذاری، همه به دقت مدل‌سازی شده‌اند. این طراحی ماژولار امکان تست و دیباگ هر بخش را به صورت جداگانه فراهم می‌کند و سپس آن‌ها را در یک سیستم کامل یکپارچه می‌سازد. [cite_start]این پروژه نه تنها به درک عمیق‌تر معماری کامپیوتر کمک می‌کند، بلکه نشان‌دهنده توانایی‌های Logisim-evolution در طراحی و شبیه‌سازی سیستم‌های دیجیتال پیچیده است[cite: 505, 508, 509, 510, 511, 512, 513].

---

Created By - Nima Ghaffari & Parsa Zandi

---

<p align="left">
  <a href="https://t.me/nimaghaffari001" style="margin-right: 10px;">
    <img src="https://img.shields.io/badge/Private%20Message-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram PV">
  </a>
  
  <a href="https://t.me/CallMeNiMChe">
    <img src="https://img.shields.io/badge/Telegram%20Channel-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Channel">
  </a>
</p>

---